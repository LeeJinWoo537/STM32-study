# ✏️ **ICM20948 데이터시트 공부!**
### 1️⃣ **Bank가 뭐냐면 한마디로**
👉 **레지스터 묶음(페이지)** 이야.

ICM 같은 센서는
- 설정 레지스터
- 가속도 데이터
- 자이로 데이터
- DMP, 전원, 필터 설정 등

이게 엄청 많아.     <br>
근데 레지스터 주소는 **0x00 ~ 0x7F** 정도로 한정돼 있거든.

그래서 제조사가 쓴 꼼수(?)가 바로 **Bank** 👇

> **같은 주소라도, Bank가 다르면 완전히 다른 레지스터**

<br>

### 2️⃣ **왜 Bank가 필요한데?**
📦 예를 들어 보자:
- Bank 0 → 센서 데이터 (Accel, Gyro, Temp)
- Bank 1 → 자이로/가속도 설정
- Bank 2 → 필터, 샘플레이트
- Bank 3 → DMP 관련 고급 설정

주소 공간이 부족하니까          <br>
👉 **“서랍을 여러 개 만들고, 지금 어느 서랍을 볼지 선택” 하는 구조야.**

<br>

### 3️⃣ **Bank 선택은 어떻게 하냐?**
ICM 계열은 보통 이 레지스터로 Bank를 바꿔:
```scss
REG_BANK_SEL (보통 0x7F)
```

예:
```c
// Bank 0 선택
write_reg(0x7F, 0x00);

// Bank 1 선택
write_reg(0x7F, 0x10);

// Bank 2 선택
write_reg(0x7F, 0x20);

// Bank 3 선택
write_reg(0x7F, 0x30);
```
💡 하위 비트는 안 쓰고          <br>
상위 2비트(0x00, 0x10, 0x20, 0x30)로 Bank를 구분해.

<br>

### 4️⃣ **데이터시트에서 이렇게 보일 거야**
예를 들면:
```yaml
Bank 0:
  ACCEL_XOUT_H (0x2D)
  ACCEL_XOUT_L (0x2E)

Bank 2:
  ACCEL_CONFIG (0x14)
```
말은 뭐냐면 👇

- 0x2D라는 주소는       <br>
👉 **Bank 0에서만 의미가 있음**
- Bank 2에서 0x2D를 읽으면          <br>
👉 전혀 다른 레지스터거나 의미 없음

<br>

### 5️⃣ **실무에서 제일 많이 터지는 실수** ⚠️
🔥 **Bank 안 바꾸고 레지스터 접근**
```c
write_reg(ACCEL_CONFIG, 0x01); // 안 됨
```
이렇게 하면:
- 내가 생각한 ACCEL_CONFIG가 아니라
- 다른 Bank의 전혀 엉뚱한 레지스터를 건드릴 수 있음

#### ✅ **항상 이렇게 해야 안전:**
```c
select_bank(2);
write_reg(ACCEL_CONFIG, 0x01);
select_bank(0); // 다시 데이터 읽는 Bank로
```

<br>

### 6️⃣ **MPU9250이랑 비교하면**
네가 전에 보던 **MPU9250**은:
- Bank 개념 거의 없음
- 주소가 고정 → 직관적

ICM은:
- Bank 있음
- 대신 기능 많고 고급 설정 가능

👉 그래서 **ICM이 더 복잡하게 느껴지는 게 정상이야** 😄

### 🤔 **갑자기 왜 Bank가 나와?**
**한 줄:** Bank = ICM20948 칩 안에 있는 레지스터들을 묶어 둔 **“페이지(층)”**.
- **같은 주소 번호**(0x00, 0x06, 0x2D …)를 **여러 묶음(Bank)에서 따로 쓸 수 있게** 한 것.
- **0x7F**에 값을 써서 “지금부터 읽/쓰는 주소는 이 Bank 안의 주소”라고 정해 줌.
### 🤔 **0x00이 리셋이랑 다른 기능을 나눠서 쓰는 거 아냐? 그게 Bank 아냐?**

**아니요. 다른 개념이에요.**

- **아닌 것:** 주소 0x00 **하나**가 리셋 + 다른 기능을 하고, 그걸 Bank로 나눠 쓴다 (X).
- **맞는 것:** **0x00이라는 “번호”를 가진 레지스터가 Bank마다 따로 있음.** 각각 **서로 다른 레지스터**이고, **기능도 하나씩**.
  - Bank 0의 0x00 → WHO_AM_I (칩 ID)
  - Bank 1의 0x00 → 완전히 다른 레지스터
  - Bank 2의 0x00 → 또 다른 레지스터  
→ “한 레지스터를 기능별로 나눠 쓴다”가 아니라 **레지스터 자체가 Bank마다 따로 있다**는 개념.


### 🤔 **레지스터 주소를 우리가 임의로 정해서 여러 개로 쓸 수 있게 하는 거 아냐?**

**아니요.**     <br>
레지스터 주소·Bank 구조 **전부 제조사(InvenSense/TDK)가 칩 설계할 때 정해 둔 것**이다.  
우리는 **데이터시트에 나온 대로** “Bank 선택 → 이 주소 읽기/쓰기”만 하는 거지, 주소를 마음대로 정하거나 바꾸는 게 아님.  
Bank가 있는 칩은 **처음부터 그렇게 설계된 것**이다.

---

### 🤔 **그럼 제조사가 애초에 Bank를 나눠 둔 거고, 똑같은 주소값을 Bank마다 따로 쓰는 거지?**

**네, 맞아요.**         <br>
제조사가 처음부터 Bank를 나눠 둔 거고, **같은 주소 번호(0x00, 0x06 …)를 Bank마다 따로 쓴다**는 이야기 맞음.

> **그니까 쉽게 이야기해서 제조사가 여러층(Bank)을 나누고 설정함 각층에 해당 주소값을 사용**        <br>
> **그니까 내가 임의로 정하는것도 아니고 해당 칩을 만드는 제조사에서 각각 레지스터 주소를 설정함**

- 근데 문제는 레지스터 주소가 너무 많아서 주소값이 똑같은 레지스터 주소가 많다 그래서 Bank를 나눠서 그니까 각 층을 나눠서 이 레지스터는 리셋, 여기있는 레지스터는 다른데에 쓰이고 이걸 각층(Bank)로 나눠서 사용한다고 생각하면 돼!

```C
/* 뱅크 선택: 레지스터 접근 전에 0x7F에 쓸 값. 이걸 써야 그 다음 주소가 어느 Bank인지 정해짐 */
#define ICM20948_REG_BANK_SEL     0x7FU
#define ICM20948_BANK_0           0x00U   /* 0층: WHO_AM_I, 전원, 가속도/자이로 데이터, 마그 수신 버퍼 등 */
#define ICM20948_BANK_2           0x20U   /* 2층: 자이로/가속도 스케일·필터 설정 */
#define ICM20948_BANK_3           0x30U   /* 3층: 내부 마그(AK09916) 접근용 I2C 마스터·SLV0 설정 */

/* Bank 0 레지스터 주소들 */
#define ICM20948_WHO_AM_I_REG     0x00U   /* 칩 ID 읽기 (0xEA 반환) */
#define ICM20948_USER_CTRL        0x03U   /* I2C 마스터 활성화 등 사용자 제어 */
#define ICM20948_PWR_MGMT_1       0x06U   /* 전원 관리1: 리셋, 슬립, 클럭 소스 선택 */
#define ICM20948_PWR_MGMT_2       0x07U   /* 전원 관리2: 가속도/자이로 축별 온/오프 */


/* Bank 3 레지스터: 내부 I2C 마스터로 AK09916(마그) 접근할 때 씀 */
#define ICM20948_I2C_MST_CTRL     0x01U   /* I2C 마스터 클럭 속도 설정 */
#define ICM20948_I2C_SLV0_ADDR    0x03U   /* 슬레이브0 I2C 주소 (읽기비트 포함) */
#define ICM20948_I2C_SLV0_REG     0x04U   /* 슬레이브0에서 읽/쓸 레지스터 주소 */
#define ICM20948_I2C_SLV0_CTRL    0x05U   /* 슬레이브0 동작 제어 (바이트 수, 읽기/쓰기, 활성화) */
#define ICM20948_I2C_SLV0_DO      0x06U   /* 슬레이브0 쓰기 시 보낼 데이터 1바이트 */
```
- 위에 코드 매크로를 보면 알 수 있는데 Bank0에 보면 `ICM20948_USER_CTRL  0x03U` 이거랑 Bank3에 있는 `ICM20948_I2C_SLV0_ADDR  0x03U` 이거랑 보면 레지스터 주소가 똑같잖아?
- 이런식으로 레지스터가 주소가 중복되는게 많다보니까 제조사에서 Bank(각 층)를 나누어서 Bank0에서 0x03U는 이것! Bank3에서 0x03U는 저것!으로 나눈 것

----------------------------------------------------------------------------------------------------------------------------------------

### 🤔 **추가로 궁금한 것**

### I2C 마스터 / 슬레이브

- **보드 위 I2C (STM32 ↔ ICM20948):**
  - **마스터:** STM32 — 통신을 시작하고, SCL(클럭)을 만들고, 레지스터 읽기/쓰기를 요청함.
  - **슬레이브:** ICM20948 — 주소 0x68 또는 0x69. STM32가 이 주소로 접근할 때만 응답함.
- **ICM20948 내부 I2C (마그 접근용):**
  - **마스터:** ICM20948 내부 I2C 마스터 (`USER_CTRL`의 `I2C_MST_EN`으로 활성화).
  - **슬레이브:** AK09916(자력계) — 주소 0x0C. STM32는 AK09916에 직접 접근하지 않고, ICM20948에게 "마그 레지스터 읽어와"라고 하면 ICM20948이 내부 마스터로 AK09916에서 읽어서 결과를 `EXT_SLV_SENS_DATA_00`(0x3B)부터 채워 줌.


### 매크로 뒤에 붙는 `U` (예: `0x03U`)

- **의미:** 이 리터럴은 **unsigned**(부호 없는 정수).
- **이유:** 레지스터 주소·비트마스크는 `uint8_t` 등 unsigned로 다루는데, 리터럴이 기본 `int`로 해석되면 부호/무부호 혼합 경고가 날 수 있음. `0x03U`처럼 쓰면 처음부터 unsigned라 경고가 사라짐.
- **비트 연산:** `1U << n`처럼 쓸 때, `1`을 signed로 두면 시프트 결과가 예상과 다르거나 경고가 남. `1U`로 두면 unsigned 시프트로 안전함.
---------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **DLPF가 뭐냐면**
#### **DLPF = Digital Low Pass Filter**
👉 **디지털 저역통과 필터**

한 줄로 말하면:

> **센서에서 튀는 고주파 노이즈를 잘라내는 필터**

<br>

### 2️⃣ **왜 필요한데?**
가속도/자이로는 실제로 이런 신호를 내:
- 손떨림
- 진동
- 전원 노이즈
- 내부 ADC 잡음

그래서 원신호는 대충 이런 느낌 👇
```
실제 움직임:   ────╮      ╭────
센서 원출력:   ─╯╰─╯╰╯╰╯╰╯╰─
```
DLPF를 켜면 👇
```nginx
DLPF 적용 후:  ─────╮    ╭────
```
👉 **덜 흔들리고, 더 쓰기 좋은 데이터**

### 3️⃣ **Low Pass가 무슨 뜻이야?**
- **Low (저주파)** → 우리가 원하는 실제 움직임
- **High (고주파)** → 노이즈, 미세 진동

DLPF는:
- 저주파는 통과 ✅
- 고주파는 차단 ❌

<br>

### 4️⃣ **근데 공짜는 아니다** ⚠️
DLPF를 켜면 단점도 있음:

#### ⏱ **지연(Latency)**
필터를 통과하면서 **몇 ms 늦어짐**
- 로봇 자세제어 → 너무 세면 안 됨
- 손떨림 보정, 로그 → 문제 없음

#### 📉 **대역폭 감소**
- 빠른 회전/충격 → 둔하게 보일 수 있음

<br>

### 5️⃣ **ICM에서 DLPF는 어디서 설정해?**
보통 이런 레지스터들에 있어:
- **GYRO_CONFIG / GYRO_CONFIG_1**
- **ACCEL_CONFIG / ACCEL_CONFIG_1**
- (Bank 2에 있는 경우 많음)

예:
```c
select_bank(2);
write_reg(GYRO_CONFIG_1, DLPF_CFG);
write_reg(ACCEL_CONFIG_1, DLPF_CFG);
```
📌 DLPF 설정 값은:
- 컷오프 주파수 (Hz)
- 내부 샘플레이트

이랑 묶여 있음

<br>

### 6️⃣ **DLPF 설정값이 의미하는 것**
데이터시트 보면 이런 표 있을 거야 👇

| **DLPF_CFG** | **컷오프 주파수** | **지연 (Delay)** |
| :---: | :---: | :--- |
| 0 | 250 Hz | 거의 없음 |
| 1 | 184 Hz | ↓ |
| 2 | 92 Hz | ↓↓ |
| 3 | 41 Hz | ↓↓↓ |
| 4 | 20 Hz | 많이 |
| 5 | 10 Hz | 많이 |

👉 숫자 커질수록:
- 더 부드러움
- 더 느려짐

### 7️⃣ **언제 어떻게 쓰면 좋아?**
🟢 **일반적인 추천**
- **IMU 자세 추정:** 41~92Hz
- **사람 움직임:** 20~41Hz
- **드론/빠른 제어:** 92~184Hz
- **진동 심한 환경:** 10~20Hz

-----------------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **CNTL = Control**
**CNTL은 그냥 `CONTROL`의 줄임말이야.**

즉,

> **CNTL 레지스터 = 뭔가를 “제어/설정”하는 레지스터**

### 2️⃣ **CNTL 레지스터가 주로 하는 일**
#### 🔹 **동작 모드 설정**
- Power-down(파워다운)
- Standby(대기)
- Continuous measurement(연속 측정)
- Single measurement(단일 측정)

#### 🔹 **측정 주기 설정**
- 8Hz
- 100Hz
- 1kHz …

#### 🔹 **리셋**
- Soft reset
- 측정 재시작

<br>

### 3️⃣ **네가 전에 본 CNTL1 / CNTL2 예시**
(이거 아마 **AK8963 자력계** 데이터시트에서 본 거일 확률 높아)

#### 📌 **CNTL1**
👉 **측정 모드 설정**
- Power-down
- Single measurement
- Continuous measurement (1 / 2)

#### 📌 **CNTL2**
👉 **리셋 전용**
- Soft reset 비트 하나 있음

즉:
- CNTL1 = “어떻게 측정할지”
- CNTL2 = “한 번 싹 초기화”
- **AK09916에서:** `CNTL2`(0x31) = 측정 모드(연속/단발), `CNTL3`(0x32) = 소프트 리셋. 여기에 값을 **쓰면** 센서 동작이 **제어**됨.
- 코드에서는 CNT1 = CNTL2로 바꾼거같다 CNTL3도 마찬가지

----------------------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **LSB가 뭐냐면**
**LSB = Least Significant Bit**

👉 **가장 덜 중요한 비트,**             <br>
👉 **값 변화에 가장 작은 영향을 주는 비트**

### 0️⃣ **결론 먼저 (이 문장 하나만 붙잡아)**
> **LSB = 숫자가 +1 변하는 “한 칸”을 말하는 것**

진짜로 그게 전부야.     <br>
이제 그걸 왜 쓰는지만 설명할게.

<br>

### 1️⃣ **“+1 한 칸”이 무슨 뜻이냐면**
숫자부터 보자.
```
0, 1, 2, 3, 4, 5
```
여기서:
- 0 → 1 : +1
- 1 → 2 : +1

이 **+1 변화 하나**         <br>
👉 그걸 **1 LSB** 라고 부르는 거야.

📌 그래서 네가 물은 질문에 답하면:

> 👉 **맞아, LSB는 그냥 +1을 말하는 거야**

<br>

### 2️⃣ **그럼 raw는 뭐냐?**
**raw = 센서 값이면서 변수**

아무 단위도 없음.   <br>
의미도 없음.    <br>
그냥 숫자.

예:
```c
raw = 7
```
이 말은:

> 센서가 “7칸만큼 세졌다”고 말한 것

✔️ 아직:
- µT ❌
- 자기장 ❌
- 물리량 ❌

그냥 **숫자 7**

<br>

### 3️⃣ **이제 “자(尺)” 비유 다시 (이번엔 더 정확하게)**
자에는 이런 게 있지:
```lua
|----|----|----|----|
 1cm  1cm  1cm  1cm
```
여기서:
- 한 칸 = 1cm

👉 이때:
- **한 칸 = 기준**
- 그 기준이 바로 **LSB 같은 역할**

<br>

### 4️⃣ **센서에는 “cm”가 없어서 문제임**
센서는 이렇게 생겼어 👇
```lua
|----|----|----|----|
  ?     ?     ?     ?
```
그래서 데이터시트가 말해주는 게 이거야:

> **“야, 이 센서는 한 칸이 0.15 µT야”**

즉:
- 센서의 **1칸(LSB) = 0.15 µT**

<br>

### 5️⃣ **그래서 1칸이 뭐냐고?**
이 질문이 핵심이야.

> ❓ 1칸은 뭐야?

👉 답:
> **센서가 구분할 수 있는 가장 작은 변화량**

더 작게는 구분 못 함.

<br>

### 6️⃣ **숫자로 연결해보자 (진짜 중요)**
#### **예시**
- raw = 1       <br>
→ 센서 눈금 1칸

- raw = 2     <br>
→ 센서 눈금 2칸

- raw = 10        <br>
→ 센서 눈금 10칸

그리고:
- 1칸 = 0.15 µT

그래서:
```markdown
raw = 10
→ 10칸
→ 10 × 0.15 = 1.5 µT
```

<br>

### 7️⃣ **그럼 LSB는 “측정 용도”냐?**
아니, **LSB는 측정기가 아님** ❌

정확한 말은 이거야:

> **LSB는 센서가 세는 눈금의 크기를 설명하기 위한 말**

- “이 센서는 한 칸이 얼마나 되냐?”
- 그걸 설명할 때 LSB라는 단어를 쓰는 거야

<br>

### 8️⃣ **진짜 최종 정리 (이거만 기억해)**
- raw = 센서가 준 숫자
- LSB = 그 숫자가 +1 변하는 한 칸
- 1칸이 얼마냐 = 데이터시트가 알려줌
- AK09916은:
    - 1칸 = 0.15 µT

```c
/* raw값 * 이 수 = 마이크로테슬라(uT) */
```
여기서 **“이 수”**의 의미는 딱 하나야.

> **raw 숫자 1이 실제 세계에서 얼마나 되는지를 알려주는 환산비율**

더 줄이면:
> **“숫자 1칸 = 실제로 얼마냐”**

<br>

### 3️⃣ **그래서 0.15 µT는 어디서 왔냐?**
👉 **맞아, 이건 데이터시트에 적혀 있는 값이야.**

AK09916 데이터시트에 이렇게 써 있어 (표로):
```r
Sensitivity (typ): 0.15 µT / LSB
```
이 문장을 그대로 풀면:
- Sensitivity = 민감도
- 0.15 µT / LSB =       <br>
👉 LSB 1칸당 0.15 마이크로테슬라

<br>

### 1️⃣ **마이크로테슬라(µT)는 단위 이름이 맞아**
응, **단위 이름**이야.
- **테슬라(T)** → 자기장의 세기 단위
- **마이크로(µ)** → 1/1,000,000

그래서:
```r
1 µT = 0.000001 T
```
#### **참고로 감각 잡기**
- 지구 자기장 ≈ 25 ~ 65 µT
- 자력계는 보통 µT 단위를 씀

<br>

### 2️⃣ **그럼 질문 핵심으로 가자**
> **“LSB를 왜 써? 왜 한 칸의 단위를 알아야 해?”**

이게 핵심이야.

<br>

### 3️⃣ **센서는 ‘숫자’밖에 못 줘**
센서 내부에서는 이런 일만 일어나:
- 실제 자기장 → 전압
- 전압 → 숫자

결과:
```ini
raw = 123
```
센서는 **“123”만 던져줌**       <br>
절대 “18.45 µT입니다~” 이런 말 못 함 ❌

<br>

### 4️⃣ **MCU / 사람이 진짜로 원하는 건 이거야**
우리가 알고 싶은 건:
- 이게 얼마나 센 자기장이냐
- 방향 계산
- 각도 계산
- 지도랑 비교

👉 **즉 물리적인 의미 있는 값**

<br>

### 5️⃣ **그래서 “한 칸이 얼마냐”가 필요함**
raw = 123 이라는 말은:

> **“센서 눈금으로 123칸”**

근데:
- 이 눈금이 1cm인지
- 1mm인지
- 1km인지

모르면 **아무 의미가 없음.**

**그래서 제조사가 말해주는 게 이거야:**

> **“이 센서는 눈금 한 칸이 0.15 µT야”**

<br>

### 6️⃣ **LSB는 ‘번역기’ 같은 역할**
- raw 숫자 → 센서 내부 언어
- µT → 인간/물리 세계 언어

👉 **LSB 스케일 값이 번역기**
```c
현실값 = raw × (µT / LSB)
```

<br>

### 7️⃣ **단위 몰라도 쓰는 경우도 있긴 해**
사실 솔직히 말하면 👇
- 상대 비교
- 방향만 필요
- 크기 중요 없음

이런 경우엔:
- raw 그대로 써도 됨

하지만 ❌:
- 다른 센서랑 비교
- 알고리즘 적용
- 보정
- 데이터시트 기반 계산

👉 이건 **단위 필수**

### 9️⃣ **마지막으로 한 비유 (이번엔 딱 맞는 걸로)**
센서 raw 값 =   <br>
📏 **눈금이 없는 자로 잰 숫자**

LSB 정보 =      <br>
📐 **“이 자는 한 칸이 몇 cm인지” 알려주는 설명서**

---------------------------------------------------------------------------------------------------------------------------------------------------

### FSR (Full Scale Range)
- **의미:** 센서가 측정할 수 있는 **최대 범위(±값)**.
- **예:** 자이로 ±250/500/1000/2000 dps, 가속도 ±2g/±4g/±8g/±16g.
- **특성:** FSR을 **줄이면** 해상도(LSB당 실제 단위)가 촘촘해져 작은 변화에 민감. **키우면** 큰 움직임을 담을 수 있지만 LSB당 단위가 커져 작은 변화에 둔감.

> **센서가 “최대 어디까지” 측정할 수 있는 범위**

### 2️⃣ **감각적으로 먼저 보자**
가속도 센서 예시 👇
- FSR = **±2 g**
- FSR = **±4 g**
- FSR = **±8 g**
- FSR = **±16 g**

이 말은:
- **-2g ~ +2g** 까지 측정 가능
- **-16g ~ +16g** 까지도 가능 (대신 덜 세밀)

<br>

### 3️⃣ **왜 FSR를 바꿀 수 있게 해놨을까?**
이게 핵심 이유야 👇

#### 🔹 **FSR 작게**
- 측정 범위 좁음
- 대신 **아주 세밀**
- 작은 움직임 잘 보임
- 노이즈 적음

#### 🔹 **FSR 크게**
- 큰 충격도 안 잘림
- 대신 한 칸(LSB)이 커짐
- 작은 변화엔 둔함

👉 **정밀도 vs 범위 트레이드오프**

<br>

### 4️⃣ **FSR이 LSB랑 직접 연결됨**
여기서 아까 배운 LSB가 다시 등장한다 😄

예를 들어:
- 16비트 ADC
- FSR = ±2g

👉 전체 범위 = 4g   <br>
👉 이걸 65536칸으로 나눔
```css
1 LSB ≈ 4g / 65536 ≈ 0.000061 g
```
FSR를 키우면:
- 전체 범위 ↑
- 1칸(LSB) 크기 ↑

<br>

### 5️⃣ **그래서 데이터시트에 이런 게 나와**
예:
```bash
Sensitivity:
±2g  → 16384 LSB/g
±4g  → 8192  LSB/g
±8g  → 4096  LSB/g
±16g → 2048  LSB/g
```
👉 FSR 설정에 따라 **raw → 실제값 변환 계수**가 달라짐

<br>

### 6️⃣ **코드에서 FSR가 쓰이는 위치**
보통 이런 레지스터에 있어:
- ACCEL_CONFIG
- GYRO_CONFIG

예:
```c
// 가속도 FSR = ±4g
write_reg(ACCEL_CONFIG, 0x01);
```
그리고 변환할 때:
```c
float accel_g = raw / 8192.0f;
```

<br>

### 7️⃣ **언제 어떤 FSR를 쓰면 좋을까?**
#### **추천 감각**
- **손에 든 IMU / 자세 추정** → ±2g
- **사람 움직임** → ±4g
- **로봇 / 드론** → ±8g
- **충격 센싱** → ±16g

<br>

### 8️⃣ **한 문장으로 정리**
> **FSR은 “센서 눈금 전체 길이”를 정하는 설정이다.**        <br>
> **그래서 FSR를 정해야 LSB 크기도 정해진다.**

-------------------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **PLL이 뭐냐면**
#### **PLL = Phase Locked Loop**

한 줄로 말하면:

> **기준 신호에 맞춰서 ‘속도(주파수)’를 자동으로 따라가는 회로**

더 쉽게 말하면:

> **박자 맞추는 장치**

<br>

### 2️⃣ **센서에서 PLL가 왜 나오냐?**
ICM / MPU 데이터시트에서 PLL은 보통 이런 문맥으로 나와:
- Clock source(시계 소스)
- PLL with X-axis gyroscope(X축 자이로스코프를 사용한 PLL)
- Auto select PLL or internal oscillator(PLL 또는 내부 발진기 자동 선택)

즉:
> **센서 내부 시간 기준(클럭)을 뭘로 쓸 거냐는 얘기야.**

<br>

### 3️⃣ **왜 클럭이 중요하냐?**
센서는 내부에서 계속 이걸 하고 있어:
- 샘플링 (언제 측정할지)
- 필터 (DLPF)
- 데이터 출력 타이밍

👉 이게 전부 **시간 정확도**에 의존함.
클럭이 흔들리면:
- 샘플 간격 불규칙
- 필터 특성 틀어짐
- 데이터 노이즈 증가

<br>

### 6️⃣ **그래서 ICM에서는 어떻게 쓰이냐?**
보통 이런 설정이 있어:
- Internal 20MHz oscillator
- PLL with Gyro X
- PLL with Gyro Y
- PLL with Gyro Z

실무에서는:         <br>
👉 **PLL with Gyro X** 같은 걸 많이 씀      <br>
(자이로가 내부에서 제일 안정적인 기준이기 때문)

<br>

### 7️⃣ **이게 센서 데이터랑 무슨 상관이냐?**
클럭 안정성 ↑ →
- 샘플링 정확 ↑
- 노이즈 ↓
- 드리프트 ↓

즉:

> **데이터 품질이 좋아짐**

### 🤔 **이거 클럭이 혹시 I2C에 있는 SCL 이런거 이야기하는거야?**

### **결론부터**
> **PLL에서 말하는 클럭 ≠ I2C의 SCL**

### 1️⃣ **I2C의 SCL은 뭐냐면**
- SCL = 통신용 박자
- MCU가 “지금 비트 하나 보낸다” 알려주는 신호
- 역할: 데이터를 주고받는 타이밍

👉 **센서랑 대화할 때만 쓰는 시계**

<br>

### 2️⃣ **PLL에서 말하는 클럭은 뭐냐면**
- **센서 내부용 시계**
- 센서가 혼자 일할 때 쓰는 시간 기준

이걸로:
- 언제 측정할지
- 필터 계산 타이밍
- 내부 ADC 샘플링

👉 **센서 뇌 속 시계**

<br>

### 3️⃣ **둘을 비유로 나누면**
- I2C SCL =     <br>
📞 전화 통화할 때 말하는 속도

- PLL 클럭 =        <br>
🧠 생각하는 속도, 심장 박동

전화 끊어도 심장은 계속 뜀.

---------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **dps가 뭐냐면**
**dps = degrees per second**

👉 **1초에 몇 도(degree) 회전하느냐**를 뜻하는 단위야.

<br>

### 2️⃣ **감각적으로 바로 예시**
- **90 dps**            <br>
→ 1초에 90도 회전   <br>
→ 1초에 반 바퀴의 1/4

- **360 dps**       <br>
→ 1초에 한 바퀴 회전

- **-45 dps**       <br>
→ 반대 방향으로 1초에 45도 회전

부호(±)는 **회전 방향**을 뜻해.

<br>

### 3️⃣ **어디서 쓰이냐?**
👉 **자이로 센서 출력 단위**

자이로는:
- “얼마나 돌아갔냐?” ❌
- **“지금 얼마나 빨리 돌고 있냐?”** ⭕

그 “속도”가 바로 **dps**야.

<br>

### 4️⃣ **FSR랑 연결해보면**
자이로 FSR 예시:
- ±250 dps
- ±500 dps
- ±1000 dps
- ±2000 dps

의미:
- **최대 회전 속도 범위**

예:
- ±250 dps → 천천히, 정밀
- ±2000 dps → 겁나 빠른 회전도 안 잘림

<br>

### 5️⃣ **raw → dps 변환**
데이터시트에 이런 게 있음:
```bash
±250 dps → 131 LSB/dps
```
이 말은:
- **1 dps = raw 131칸**

그래서 코드에서는:
```c
float gyro_dps = raw / 131.0f;
```

<br>

### 6️⃣ **왜 rad/s 안 쓰고 dps 쓰냐?**
사실 제어/물리 쪽은 **rad/s**가 더 정석이야.

하지만:
- 사람이 직관적으로 이해하기 쉬움
- 각도(deg)랑 바로 연결됨

그래서 센서 기본 단위는 dps를 많이 씀.

필요하면:
```c
rad_s = dps * (π / 180)
```

<br>

### 7️⃣ **한 문장으로 끝**
> **dps는 “1초에 몇 도로 회전 중인가”를 나타내는 자이로 단위다.**

### 🤔 **회전한다는게 개념이 자이로가 예를 들어서 기본값에서 45도기울렸어 그러면 45도 회전한거고 그게 1초라고 했을 때를 나타내는거야?**
### **먼저 한 줄 결론**
> ❌ **자이로는 “45도 기울어졌다”를 말해주지 않는다**       <br>
> ⭕ **자이로는 “지금 초당 몇 도로 움직이고 있다”를 말해준다**

### **네가 말한 상황을 그대로 써보자**
> “기본값에서 45도 기울였고, 그게 1초면?”

이걸 **자이로 관점**으로 번역하면 이렇게야 👇

#### **경우** 1️⃣
- 1초 동안
- 0도 → 45도로 이동

👉 이때 자이로가 말하는 값은:
```
45 dps
```
왜냐면:
- 1초에 45도 움직였으니까

#### **경우** 2️⃣
- 이미 45도로 기울여 놓고
- **가만히 유지**

👉 이때 자이로 값은:
```
0 dps
```
중요 포인트야 ⚠️        <br>
**기울어져 있어도 안 움직이면 자이로는 0**

### **그래서 자이로는 “속도계”야**
비유로 말하면:
- 가속도계 → 위치 느낌
- 자이로 → **회전 속도계**

자동차로 치면:
- 속도계는 “지금 몇 km/h?”
- 위치는 직접 안 알려줌

자이로도 똑같아.

### **그럼 각도는 어디서 나오냐?**
자이로 값(dps)을 **시간에 대해 계속 더하면(적분)** 각도가 돼.

예:
```text
1초 동안 45 dps → 45°
0.5초 동안 45 dps → 22.5°
```
즉:
```
각도 = ∫ (dps) dt
```

### **근데 왜 자이로만 쓰면 안 되냐?**
여기서 중요한 현실 문제가 생김 👇
- 자이로는 **조금씩 오차**가 있음
- 0이어야 할 때도 +0.1 dps 이런 값 나옴

이걸 계속 적분하면:
- 가만히 있어도 각도가 계속 늘어남 ❌       <br>
(이걸 드리프트라고 해)

### **그래서 가속도계랑 같이 씀**
- 자이로 → 빠르고 부드러운 변화
- 가속도계 → 절대적인 기울기 기준

👉 둘을 섞어서:
- Complementary filter (보완 필터)
- Kalman filter (칼만 필터)

### **그림 없이 말로 정리하면**
- “45도로 기울어졌다” → **각도 (자이로 아님)**
- “1초에 45도 움직였다” → **45 dps (자이로)**
- “기울어진 채로 멈춤” → **0 dps**

### **진짜 한 문장 요약**
> **자이로는 ‘얼마나 기울어졌는지’가 아니라**       <br>
> **‘지금 얼마나 빨리 기울어지고 있는지’를 본다.**

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **ICM20948_PWR_MGMT_2 (0x07)**
#### 👉 **가속도/자이로 전원 스위치 레지스터**
```c
#define ICM20948_PWR_MGMT_2  0x07
```
이 레지스터는 **Accel / Gyro 축별로 켜고 끄는 스위치야.**
```c
0x00  // 가속도 XYZ ON, 자이로 XYZ ON
0x3F  // 가속도 XYZ OFF, 자이로 XYZ OFF
0x07  // Gyro XYZ OFF, Accel XYZ ON
```

#### **핵심 포인트**
- Mag랑은 전혀 상관없음
- Accel / Gyro만 제어
- 저전력, 디버깅, 특정 센서만 쓰고 싶을 때 필수

### **다시 한번 말하지만!**
> ❌ “가속계 ON/OFF, 자이로 ON/OFF” 만 하는 레지스터는 아니고       <br>
> ✅ **가속계/자이로를 축 단위로 끄고 켜는 레지스터가 맞아**

### **PWR_MGMT_2 비트 구조 다시 정확히 보자**
```arduino
bit 7  6  5 | 4  3  2 | 1 0
  XG YG ZG | XA YA ZA | -
```
- 1 → 해당 축 **Disable**
- 0 → 해당 축 **Enable**

#### **즉 논리적으로는**
- X/Y/Z **각 축 독립 제어 가능** ✔
- “축별”이라는 말은 **데이터시트 기준으로는 100% 맞음**

#### **그럼 왜 너 말이 맞게 느껴지냐?**
👉 **현실에서는 이렇게 씀**

#### 1️⃣ **자이로 전부 끄거나 전부 켠다**
```c
// Gyro OFF, Accel ON
write_reg(PWR_MGMT_2, 0x07);  // 0000 0111
```

### 2️⃣ **가속도 전부 끄거나 전부 켠다**
```c
// Accel OFF, Gyro ON
write_reg(PWR_MGMT_2, 0x38);  // 0011 1000
```
👉 **부분 축만 켜는 경우 거의 없음**

그래서 체감상:

> “아 그냥 가속계/자이로 ON/OFF네?”

라고 느끼는 게 너무 정상임 😄

### **근데 왜 굳이 축별로 만들어놨을까?**
### **이유 1️⃣ 전력 최적화 (모바일용)**
- 예: Z축만 필요 (수평 상태 감지)
- 나머지 축 OFF → µA 단위 절약

### **이유 2️⃣ 특정 축 노이즈 / 고장 회피**
- 특정 축만 사용 안 하는 설계 가능

### **이유 3️⃣ 테스트 & 캘리브레이션**
- 공장 테스트 / 개발 중 디버깅

#### 🚨 **중요한 주의사항 하나**
> **축을 꺼도 레지스터는 읽힌다**

- 값은 0이거나 마지막 값일 수 있음
- “꺼져 있는데 왜 값이 있지?” → 정상 동작임

#### **한 문장으로 정확하게 말하면**
> **PWR_MGMT_2는 설계상 ‘축별 전원 제어’가 맞고,**      <br>
> **실사용에서는 대부분 ‘센서 단위 ON/OFF’처럼 쓴다**


-------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 2️⃣ **AK09916_ST1 (0x10)**
👉 **마그네토미터 데이터 준비 상태 + 데이터 시작점**
```c
#define AK09916_ST1  0x10
```
이건 Mag 내부 레지스터야 (ICM20948 말고 AK09916 쪽!)

#### **ST1의 역할**
ST1은 두 가지 의미를 동시에 가짐:

✅ **(1) 데이터 준비 상태 플래그**

- `ST1[0] = DRDY`
    - `1` → 새 Mag 데이터 준비됨
    - `0` → 아직

✅ **(2) Mag 데이터 읽기의 시작 주소**
ST1부터 연속 읽기를 하면:
```scss
ST1 (0x10)
HXL
HXH
HYL
HYH
HZL
HZH
ST2 (0x18)
```
👉 **총 8바이트**

<br>

### 3️⃣ **ST2 는 뭐하는 놈이냐? (⭐중요⭐)**
```c
#define AK09916_ST2  0x18
```
이건 그냥 상태 레지스터가 아님.

### 🚨 **ST2의 진짜 역할**
#### 1️⃣ **데이터 읽기 완료 신호**
> **ST2를 읽어야 다음 측정이 시작됨**

- ST2를 안 읽으면       <br>
    → Mag 데이터가 락(lock) 걸림    <br>
    → 값이 계속 안 바뀜

👉 **Mag 데이터 읽기의 “마침표”**

<br>

### 2️⃣ **오버플로(Overflow) 체크**
ST2의 비트 중:
```mathematica
ST2[3] = HOFL (Overflow)
```
- `1` → 측정 범위 초과 → 데이터 신뢰 ❌
- `0` → 정상

### 📌 **Mag 데이터 읽기의 정석 루틴**
```text
1. ST1 읽기 → DRDY 확인
2. HXL ~ HZH 읽기
3. ST2 읽기 (반드시!)
```
ICM20948에서는 이걸 **I2C Master가 자동으로 해줌**      <br>
→ 결과만 EXT_SLV_SENS_DATA_xx에 넣어주는 거고 👍

<br>

### 4️⃣ **셋을 같이 비교하면 이렇게 딱 정리돼**

| **레지스터** | **소속** | **역할** |
| :--- | :--- | :--- |
| **PWR_MGMT_2** | ICM20948 | Accel/Gyro 전원 제어 (개별 축 활성/비활성) |
| **ST1** | AK09916 | Mag(지자기) 데이터 준비 상태 확인 및 읽기 시작 |
| **ST2** | AK09916 | 데이터 읽기 완료 확인 및 오버플로(Overflow) 체크 |


### **한 줄 요약** 🔥
- **PWR_MGMT_2**        <br>
    👉 “가속도/자이로를 켤까 말까”

- **ST1**       <br>
    👉 “마그 데이터 준비됐어? + 지금부터 읽어”

- **ST2**       <br>
    👉 “읽기 끝났어! 다음 측정 가도 돼”


------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```c
/* 물리량 변환용 스케일: 4g 범위 가속도, 500dps 자이로 기준 LSB당 값 */ 
#define ICM20948_ACCEL_SCALE_4G 8192.0f 
#define ICM20948_GYRO_SCALE_500 65.5f 
```

#### 🤔 **이거는 뭐야??**

### **이 매크로들의 정체 한 줄 요약**
> **ADC로 읽은 raw 값이 “몇 LSB = 1 물리단위인가”를 알려주는 환산 계수**

즉
- 가속도: **LSB → g**
- 자이로: **LSB → deg/s**

### **왜 이런 숫자가 나오냐부터 보자**
#### **공통 전제**
ICM20948의 Accel / Gyro 출력은:
- **16비트 signed 값** (`int16_t`)
- 범위는 설정한 Full Scale(FS)에 따라 달라짐

<br>

### 1️⃣ `ICM20948_ACCEL_SCALE_4G` = `8192.0f`
#### **의미**
> **8192 LSB = 1 g**

#### **왜 8192냐?**
- 가속도 FS = **±4 g**
- 총 범위 = **8 g**
- 16비트 signed → ±32768 LSB
```yaml
32768 LSB / 4 g = 8192 LSB / g
```
그래서:
```c
accel_g = raw_accel / 8192.0f;
```

### **예시**
- raw = 8192 → 1 g
- raw = -16384 → -2 g

<br>

### 2️⃣ `ICM20948_GYRO_SCALE_500` = `65.5f`
#### **의미**
> **65.5 LSB = 1 deg/s**

#### **왜 65.5냐?**
- 자이로 FS = **±500 dps**
- 총 범위 = **1000 dps**
```
32768 LSB / 500 dps ≈ 65.536 LSB / dps
```
데이터시트에서 **65.5**로 반올림해서 씀

그래서:
```c
gyro_dps = raw_gyro / 65.5f;
```

### **이 숫자들 안 쓰면 무슨 일이 생기냐?**
- raw 값은 그냥 **의미 없는 숫자 덩어리**
- 센서 바꾸면 스케일 바뀜
- FS 바꾸면 값 해석 완전히 틀어짐

👉 **물리량으로 쓰려면 무조건 필요**

### **Full Scale 바꾸면 이 값도 바뀐다** ⚠️

| **FS_SEL** | **Full Scale Range** | **LSB Sensitivity (LSB/g)** |
| :---: | :---: | :---: |
| 0 | ±2g | 16384 |
| 1 | ±4g | 8192 |
| 2 | ±8g | 4096 |
| 3 | ±16g | 2048 |

#### **자이로 스케일 표**

| **FS_SEL** | **Full Scale Range** | **LSB Sensitivity (LSB/dps)** |
| :---: | :---: | :---: |
| 0 | ±250 dps | 131 |
| 1 | ±500 dps | 65.5 |
| 2 | ±1000 dps | 32.8 |
| 3 | ±2000 dps | 16.4 |

👉 **레지스터 설정이랑 이 매크로는 반드시 짝으로 맞아야 함**

### **왜 `float`로 정의했냐?**
```c
8192.0f
```
- 정수 나눗셈 방지
- STM32에서 실수 연산 바로 가능
- 후처리(필터, 자세 계산) 편함


### **한 문장으로 딱 정리**
> **이 매크로들은 “이 raw 값 몇 칸이 실제 1 g / 1 dps냐”를 알려주는 변환 기준표다**

----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 😁 **`0x68U`와 `0x69U` 이거에 차이!**

```c
/* I2C 슬레이브 주소. AD0=LOW면 0x68, HIGH면 0x69. HAL은 7bit<<1 해서 8bit로 넘김. Init에서 둘 다 시도함 */
#define ICM20948_I2C_ADDR_0       (0x68U << 1)
#define ICM20948_I2C_ADDR_1       (0x69U << 1)
```
- 위에 매크로를 보면 알 수 있지만 2개가 나뉘어져 있다 왜 나뉠까?

저기 위에 있는 2개는 AD0핀을 어디다가 연결을 하느냐에 따라 주소 값이 달라진다.

그니까 그게 무슨말이냐면 브레드보드 핀 연결하는걸로 예시를 들어보자!

```
=================================== ← VCC
=================================== ← GND 
                   |         |
                   |         |
|--------|-        |         |
|ICM20948|---------| ← GND핀 |
|--------|-------------------| ← AD0 핀
```
- 이런식으로 위에 있는 것처럼 브레드보드에 GND핀과 AD0핀을 연결하면 주소값이 0x68이 된다!

또 다른 상황은?
```
=================================== ← GND
=================================== ← VCC 
                   |         |
                   |         |
|--------|-        |         |
|ICM20948|---------| ← VCC핀 |
|--------|-------------------| ← AD0 핀
```
- 위에 있는 것처럼 AD0 핀을 VCC에 연결하면 0x69 주소가 된다.

### 🤔 **음... 그러면 만약에 AD0 핀을 연결을 안하면?? 어떻게 돼?**
- 그러면 그냥 저 2개 주소값 중에 무작위로 설정이 된다.