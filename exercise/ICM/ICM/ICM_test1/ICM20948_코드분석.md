# **STM32 ICM20948 코드 분석**

(필기 스타일: 주소/레지스터/함수 하나씩 설명)

---

## **ICM20948 주소·레지스터 값**

```c
// ICM20948 I2C 주소 (7-bit). AD0=LOW → 0x68, AD0=HIGH → 0x69
#define ICM20948_I2C_ADDR_0   (0x68U << 1)   // HAL은 8bit 주소 사용 (7bit << 1)
#define ICM20948_I2C_ADDR_1   (0x69U << 1)

// WHO_AM_I: ICM20948 고유 ID
#define ICM20948_WHO_AM_I     0xEAU

// 뱅크 선택 (레지스터 접근 전마다 0x7F에 기록)
#define ICM20948_REG_BANK_SEL 0x7FU
#define ICM20948_BANK_0       0x00U
#define ICM20948_BANK_2       0x20U
#define ICM20948_BANK_3       0x30U

// Bank 0 레지스터
#define ICM20948_WHO_AM_I_REG  0x00U   // WHO_AM_I (읽으면 0xEA)
#define ICM20948_USER_CTRL     0x03U   // I2C 마스터 활성화 등
#define ICM20948_PWR_MGMT_1    0x06U   // 리셋, 클럭, 슬립
#define ICM20948_PWR_MGMT_2    0x07U   // 축별 전원
#define ICM20948_ACCEL_XOUT_H  0x2DU   // 가속도 X high → 0x2D~0x32 (X,Y,Z 각 2바이트)
#define ICM20948_GYRO_XOUT_H   0x33U   // 자이로 X high → 0x33~0x38 (X,Y,Z 각 2바이트)
#define ICM20948_EXT_SLV_SENS_DATA_00 0x3BU  // 마그 데이터 수신 버퍼

// Bank 2 (자이로/가속도 설정)
#define ICM20948_GYRO_CONFIG_1 0x01U
#define ICM20948_ACCEL_CONFIG  0x14U

// Bank 3 (내부 마그 AK09916 접근용 I2C 마스터)
#define ICM20948_I2C_MST_CTRL  0x01U
#define ICM20948_I2C_SLV0_ADDR 0x03U
#define ICM20948_I2C_SLV0_REG  0x04U
#define ICM20948_I2C_SLV0_CTRL 0x05U
#define ICM20948_I2C_SLV0_DO   0x06U

// AK09916 (자력계) — ICM20948 내부 I2C 슬레이브
#define AK09916_I2C_ADDR       0x0CU
#define AK09916_ST1            0x10U   // 마그 데이터 시작 레지스터
#define AK09916_CNTL2          0x31U   // 연속 모드 설정
#define AK09916_CNTL3          0x32U   // 소프트 리셋
#define AK09916_MAG_SCALE      0.15f   // raw → µT (마이크로테슬라)
```

---

## **ICM20948 vs MPU9250 한눈에**

| 구분 | MPU9250 | ICM20948 |
|------|---------|----------|
| I2C 주소 (7bit) | 0x68 / 0x69 | 0x68 / 0x69 (동일) |
| WHO_AM_I **주소** | 0x75 | **0x00** (Bank0 기준) |
| WHO_AM_I **값** | 0x71 | **0xEA** |
| PWR_MGMT_1 주소 | 0x6B | **0x06** (Bank0) |
| 가속도 데이터 시작 | 0x3B | **0x2D** (Bank0) |
| 자이로 데이터 시작 | 0x43 | **0x33** (Bank0) |
| 뱅크 구조 | 없음 (플랫) | **Bank 0~3** (0x7F로 선택) |
| 자력계 | AK8963 (Bypass 시 0x0C) | **AK09916**, 내부 I2C 마스터로만 접근 |

- **레지스터 주소**는 전부 ICM20948 데이터시트 / Register Map 에 나와 있음.
- ICM20948은 **뱅크**가 있어서, **같은 주소라도 뱅크마다 다른 레지스터**를 가리킴. 그래서 읽/쓰기 전에 반드시 **0x7F에 뱅크 값**을 써 줌.

---

## **함수 하나씩 설명**

### 1. `SelectBank(hi2c, addr, bank)`

- **하는 일:** ICM20948 **뱅크 선택**. 레지스터 접근 전에 호출.
- **원리:** 레지스터 주소 **0x7F**에 `bank`(0x00, 0x20, 0x30 등)를 **한 바이트 쓰기**.
- **HAL 사용:** `HAL_I2C_Mem_Write(hi2c, addr, 0x7F, I2C_MEMADD_SIZE_8BIT, &bank, 1, timeout)`.
- **파라미터:**
  - `hi2c`: 사용할 I2C 핸들.
  - `addr`: ICM20948 8bit 주소 (0x68<<1 또는 0x69<<1).
  - `bank`: `ICM20948_BANK_0`(0x00), `BANK_2`(0x20), `BANK_3`(0x30) 등.

---

### 2. `WriteReg(hi2c, addr, reg, val)`

- **하는 일:** ICM20948 **한 레지스터에 1바이트 쓰기**.
- **원리:** 현재 선택된 뱅크 안의 `reg` 주소에 `val` 1바이트 전송.
- **HAL:** `HAL_I2C_Mem_Write(hi2c, addr, reg, I2C_MEMADD_SIZE_8BIT, &val, 1, timeout)`.
- **파라미터:**
  - `reg`: 쓸 레지스터 주소 (예: PWR_MGMT_1 = 0x06).
  - `val`: 쓸 값 (예: 0x80=리셋, 0x01=PLL+슬립해제).

---

### 3. `ReadRegs(hi2c, addr, reg, buf, len)`

- **하는 일:** ICM20948 **한 레지스터부터 연속으로 len바이트 읽기**.
- **원리:** 현재 뱅크의 `reg`부터 시작해 `len`바이트를 `buf`에 받음.
- **HAL:** `HAL_I2C_Mem_Read(hi2c, addr, reg, I2C_MEMADD_SIZE_8BIT, buf, len, timeout)`.
- **파라미터:**
  - `reg`: 읽기 시작 레지스터 주소 (예: ACCEL_XOUT_H = 0x2D).
  - `buf`: 읽은 데이터를 넣을 버퍼.
  - `len`: 읽을 바이트 수 (가속도/자이로는 6, 마그는 8 등).

---

### 4. `ICM20948_Init(hicm, hi2c)`

- **하는 일:** ICM20948 + 내부 자력계(AK09916) **전체 초기화** (필터 없음).
- **순서 요약:**
  1. **주소 시도:** 먼저 0x68로 뱅크0 선택 시도 → 실패하면 0x69로 재시도. (MPU9250처럼 AD0에 따라 주소가 0x68/0x69.)
  2. **WHO_AM_I 확인:** Bank0 **0x00**에서 1바이트 읽어 **0xEA**인지 확인. (MPU9250의 0x75→0x71과 같은 "연결/칩 식별" 용도.)
  3. **리셋:** PWR_MGMT_1(0x06)에 **0x80** 써서 소프트 리셋 → 약 10ms 대기.
  4. **클럭·슬립:** PWR_MGMT_1에 **0x01** (PLL 클럭, 슬립 해제). MPU9250의 "0x6B에 0x00/0x01 쓰기"와 같은 역할.
  5. **축 켜기:** PWR_MGMT_2(0x07)에 **0x00** → 가속도·자이로 축 전부 온.
  6. **Bank2:** 자이로 500dps(GYRO_CONFIG_1), 가속도 4g(ACCEL_CONFIG) 설정.
  7. **I2C 마스터:** USER_CTRL에 I2C_MST_EN 세팅 → 내부 마그(AK09916) 접근 가능하게 함.
  8. **Bank3:** I2C 마스터 클럭 설정 후, SLV0로 AK09916에 **CNTL3=0x01** (리셋), **CNTL2=0x08** (연속 모드) 쓰기.
  9. 다시 **Bank0**으로 돌아가서 끝.

- **실패 시:** 주소/연결/WHO_AM_I 불일치면 `HAL_ERROR` 반환. main에서는 LD2 깜빡이면서 대기하는 식으로 처리 가능.

---

### 5. `ICM20948_ReadAccel(hicm, raw, g)`

- **하는 일:** 가속도 **raw 값**과 **g 단위** 값 읽기 (필터 없음).
- **동작:**
  - Bank0 선택 → **0x2D**부터 **6바이트** 읽기 (XH,XL, YH,YL, ZH,ZL).
  - 2바이트씩 묶어 **int16_t**로 만든 것이 `raw->x,y,z`.
  - `g->x,y,z` = raw / `accel_scale` (4g일 때 8192.0).
- **파라미터:**
  - `raw`: NULL이면 raw 미저장.
  - `g`: NULL이면 g 미계산.

---

### 6. `ICM20948_ReadGyro(hicm, raw, dps)`

- **하는 일:** 자이로 **raw**와 **dps(°/s)** 읽기.
- **동작:** Bank0 **0x33**부터 6바이트 읽어서, raw와 `dps`(gyro_scale 65.5로 나눈 값) 계산.
- **파라미터:** `raw`, `dps` 각각 NULL 가능.

---

### 7. `ICM20948_ReadMag(hicm, raw, ut)`

- **하는 일:** 내부 자력계 AK09916 데이터를 **ICM20948 I2C 마스터**로 읽어서 **raw**와 **µT**로 반환.
- **동작:**
  1. Bank3 선택.
  2. SLV0로 AK09916 **0x10(ST1)**부터 **8바이트** 읽기 설정 (주소 0x0C | 0x80, 읽기).
  3. Bank0으로 돌아가서 약 2ms 대기.
  4. Bank0 **0x3B(EXT_SLV_SENS_DATA_00)**부터 8바이트 읽기.
  5. 버퍼 [1,2]=HX, [3,4]=HY, [5,6]=HZ → 16비트로 묶어 raw와 `ut`(×0.15 µT/LSB) 계산.
- **의미:** 마그는 ICM20948 "안에" 있어서, MCU는 ICM20948한테 "마그 레지스터 읽어와"라고 하고, ICM20948이 읽은 결과를 0x3B~에 채워 줌.

---

### 8. `ICM20948_ReadAll(...)`

- **하는 일:** 위 **ReadAccel → ReadGyro → ReadMag**를 순서대로 호출해서, 한 번에 가속도/자이로/마그 모두 읽기.
- **반환:** 셋 다 성공 시 `HAL_OK`, 하나라도 실패 시 해당 `HAL_StatusTypeDef` 반환.

---

## **I2C / HAL 관련 (필기 스타일 요약)**

- **`hi2c1`:** I2C1용 핸들러. `Instance = I2C1`, `Init.ClockSpeed`, `Init.AddressingMode` 등은 MPU9250 할 때 쓰던 것과 같은 개념.
- **`DevAddress`:** 7bit 주소를 쓰려면 HAL에서는 보통 `(0x68 << 1)` 같이 8bit로 넘김. ICM20948도 0x68/0x69.
- **`MemAddress`:** 위에서 말한 **레지스터 주소** (0x00, 0x06, 0x2D, 0x33, 0x3B 등). ICM20948 **칩 내부** 주소이며, STM32 쪽 주소 아님.
- **`HAL_I2C_Mem_Read` / `HAL_I2C_Mem_Write`:** MPU9250에서 쓰던 것과 동일. "어느 I2C 장치(DevAddress)의 어느 레지스터(MemAddress)에서 읽/쓰기" 하는지가 ICM20948에서도 같고, 단지 **뱅크를 먼저 선택**해 주는 것만 추가됨.

---

## **WHO_AM_I / PWR_MGMT 정리 (ICM20948 기준)**

- **WHO_AM_I**
  - **주소:** Bank0 **0x00**.
  - **값:** **0xEA**.
  - 용도: MPU9250의 0x75→0x71과 같이 "연결됐는지, ICM20948이 맞는지" 확인.

- **PWR_MGMT_1**
  - **주소:** Bank0 **0x06** (MPU9250의 0x6B와 **다른 주소**, 같은 역할).
  - 리셋(bit7), 슬립(bit6), 클럭 선택(bit0 등) — MPU9250의 PWR_MGMT_1 설명하신 것과 **개념 동일**.
  - ICM20948도 전원/리셋 후 기본이 슬립일 수 있어서, Init에서 0x01 같은 값으로 "깨우기 + PLL" 해 주는 단계가 있음.

---

## **정리 (필기용 한 줄)**

- **0x68 / 0x69** = ICM20948 **I2C 주소** (AD0에 따라 선택).
- **0x00** = **WHO_AM_I 레지스터 주소**, 읽으면 **0xEA**.
- **0x06** = **PWR_MGMT_1** (리셋/슬립/클럭).
- **0x2D~0x32** = 가속도, **0x33~0x38** = 자이로 (Bank0).
- 마그는 **Bank3 SLV0**로 AK09916 제어 후, **Bank0 0x3B**에서 8바이트 읽어서 HX,HY,HZ → µT.

---

## **질문타임 (Q&A)**

### Q1. 갑자기 왜 Bank가 나와?

**이유:** ICM20948은 레지스터가 많아서 **주소 한 칸(8비트, 0x00~0xFF)으로는 다 못 넣음.**  
그래서 **“몇 번째 페이지에서 그 주소를 볼지”**를 따로 정해 주는 게 **Bank**.

- **MPU9250:** 주소 = 레지스터 하나 (1층만 있어서 Bank 없음).
- **ICM20948:** 주소를 여러 “층(Bank)”으로 나눠서, **0x7F에 Bank 값을 써 준 다음** 그 층의 주소로 읽/쓰기.

---

### Q2. Bank가 뭐야?

**한 줄:** Bank = ICM20948 칩 안에 있는 레지스터들을 묶어 둔 **“페이지(층)”**.

- **같은 주소 번호**(0x00, 0x06, 0x2D …)를 **여러 묶음(Bank)에서 따로 쓸 수 있게** 한 것.
- **0x7F**에 값을 써서 “지금부터 읽/쓰는 주소는 이 Bank 안의 주소”라고 정해 줌.

---

### Q3. 0x00이 리셋이랑 다른 기능을 나눠서 쓰는 거 아냐? 그게 Bank 아냐?

**아니요. 다른 개념이에요.**

- **아닌 것:** 주소 0x00 **하나**가 리셋 + 다른 기능을 하고, 그걸 Bank로 나눠 쓴다 (X).
- **맞는 것:** **0x00이라는 “번호”를 가진 레지스터가 Bank마다 따로 있음.** 각각 **서로 다른 레지스터**이고, **기능도 하나씩**.
  - Bank 0의 0x00 → WHO_AM_I (칩 ID)
  - Bank 1의 0x00 → 완전히 다른 레지스터
  - Bank 2의 0x00 → 또 다른 레지스터  
→ “한 레지스터를 기능별로 나눠 쓴다”가 아니라 **레지스터 자체가 Bank마다 따로 있다**는 개념.

---

### Q4. 레지스터 주소를 우리가 임의로 정해서 여러 개로 쓸 수 있게 하는 거 아냐?

**아니요.**  
레지스터 주소·Bank 구조 **전부 제조사(InvenSense/TDK)가 칩 설계할 때 정해 둔 것**이다.  
우리는 **데이터시트에 나온 대로** “Bank 선택 → 이 주소 읽기/쓰기”만 하는 거지, 주소를 마음대로 정하거나 바꾸는 게 아님.  
Bank가 있는 칩은 **처음부터 그렇게 설계된 것**이다.

---

### Q5. 그럼 제조사가 애초에 Bank를 나눠 둔 거고, 똑같은 주소값을 Bank마다 따로 쓰는 거지?

**네, 맞아요.**  
제조사가 처음부터 Bank를 나눠 둔 거고, **같은 주소 번호(0x00, 0x06 …)를 Bank마다 따로 쓴다**는 이야기 맞음.

---

## **용어·개념 정리 (추가)**

### DLPF (Digital Low-Pass Filter)

- **의미:** 디지털 저역 통과 필터. 자이로/가속도 출력에 섞이는 **고주파 노이즈**를 줄여서 값이 더 안정적으로 나오게 함.
- **코드에서:** `GYRO_CONFIG_1`, `ACCEL_CONFIG` 레지스터에서 DLPF를 **활성화**하거나 **우회(bypass)** 할 수 있음.
  - **DLPF 사용 (FCHOICE=0):** 대역폭 설정 가능(예: 41Hz). 노이즈 감소, 대신 응답이 조금 느려질 수 있음.
  - **DLPF bypass (FCHOICE=1):** 필터 끔 → 원시 데이터에 가깝게 사용. 코드 주석의 "GYRO_DLPF bypass", "ACCEL_DLPF bypass"가 이 설정.

---

### I2C 마스터 / 슬레이브

- **보드 위 I2C (STM32 ↔ ICM20948):**
  - **마스터:** STM32 — 통신을 시작하고, SCL(클럭)을 만들고, 레지스터 읽기/쓰기를 요청함.
  - **슬레이브:** ICM20948 — 주소 0x68 또는 0x69. STM32가 이 주소로 접근할 때만 응답함.
- **ICM20948 내부 I2C (마그 접근용):**
  - **마스터:** ICM20948 내부 I2C 마스터 (`USER_CTRL`의 `I2C_MST_EN`으로 활성화).
  - **슬레이브:** AK09916(자력계) — 주소 0x0C. STM32는 AK09916에 직접 접근하지 않고, ICM20948에게 "마그 레지스터 읽어와"라고 하면 ICM20948이 내부 마스터로 AK09916에서 읽어서 결과를 `EXT_SLV_SENS_DATA_00`(0x3B)부터 채워 줌.

---

### CNTL (Control)

- **의미:** Control의 줄임말. **제어 레지스터**.
- **AK09916에서:** `CNTL2`(0x31) = 측정 모드(연속/단발), `CNTL3`(0x32) = 소프트 리셋. 여기에 값을 **쓰면** 센서 동작이 **제어**됨.

---

### 레지스터 주소·센서 값: 16진수 vs 10진수

- **실제 통신:** I2C 위에는 **바이너리(0/1)** 만 오감. "16진수로 보낸다/10진수로 보낸다" 구분 없음.
- **변수에 저장:** C에서는 그냥 **숫자** (int16_t, uint8_t 등). 진법은 "표시할 때"만 정함.
- **출력:** 코드에서 `%d` → 10진수 출력, `%x` → 16진수 출력. 지금 main에서는 `%d`로 10진수 출력 중.
- **코드에서 0x2D처럼 쓰는 이유:** 데이터시트가 16진수/비트 단위로 적어 두어서 맞추기 쉽고, `0x2D`와 `45`는 **같은 값**이라 10진수로 써도 동작은 동일함.

---

### I2C_SLV0_ADDR vs I2C_SLV0_REG

- **ICM20948_I2C_SLV0_ADDR (0x03):** ICM20948 **내부** I2C 마스터가 접근할 **외부 슬레이브의 I2C 주소** (예: AK09916 = 0x0C). "어느 **장치**에 갈지".
- **ICM20948_I2C_SLV0_REG (0x04):** 그 슬레이브 **안의 어느 레지스터**를 읽/쓸지 (예: CNTL2 = 0x31). "그 장치 **안의 어떤 레지스터**를 건드릴지".
- 즉, **장치 주소 1개 + 그 장치 내부 레지스터 주소 1개**를 조합해서 내부 마스터에 넘기는 구조.

---

### 매크로 뒤에 붙는 `U` (예: `0x03U`)

- **의미:** 이 리터럴은 **unsigned**(부호 없는 정수).
- **이유:** 레지스터 주소·비트마스크는 `uint8_t` 등 unsigned로 다루는데, 리터럴이 기본 `int`로 해석되면 부호/무부호 혼합 경고가 날 수 있음. `0x03U`처럼 쓰면 처음부터 unsigned라 경고가 사라짐.
- **비트 연산:** `1U << n`처럼 쓸 때, `1`을 signed로 두면 시프트 결과가 예상과 다르거나 경고가 남. `1U`로 두면 unsigned 시프트로 안전함.

---

### AK09916_MAG_SCALE (0.15f) / raw 값

- **AK09916_MAG_SCALE:** 자력계 **raw(카운트) → 마이크로테슬라(µT)** 로 **단위를 바꿀 때** 곱하는 스케일. 데이터시트 기준 1 LSB ≈ 0.15 µT → `raw * 0.15f`로 물리량 계산.
- **raw 값:** 센서가 I2C로 보내는 **정규화 전의 센서 카운트**. 코드에서는 2바이트씩 묶어 `int16_t`로 만든 값. "해석/단위가 붙기 전의 원시 숫자".
- **단위 바꾼다** = 카운트(LSB)에 스케일을 곱해서 µT 같은 **물리 단위**로 보여주는 것.

---

### LSB (Least Significant Bit / Byte)

- **Least Significant Bit:** 이진수에서 가장 가중치가 작은 비트(2^0 자리). 센서 출력이 1 카운트 증가할 때 이 비트가 1씩 변한다고 보면 됨.
- **Least Significant Byte:** 멀티바이트 값에서 "아래 바이트"(가장 낮은 자리). 레지스터에서 MSB/LSB 두 바이트를 합쳐 16비트로 만드는 식으로 자주 씀.
- **센서 맥락:** raw 값은 "LSB 단위의 카운트". 1 LSB가 실제 물리량에서 얼마인지가 스케일(예: 0.15 µT/LSB).

---

### FSR (Full Scale Range)

- **의미:** 센서가 측정할 수 있는 **최대 범위(±값)**.
- **예:** 자이로 ±250/500/1000/2000 dps, 가속도 ±2g/±4g/±8g/±16g.
- **특성:** FSR을 **줄이면** 해상도(LSB당 실제 단위)가 촘촘해져 작은 변화에 민감. **키우면** 큰 움직임을 담을 수 있지만 LSB당 단위가 커져 작은 변화에 둔감.

---

### PLL (Phase-Locked Loop)

- **의미:** 위상 고정 루프. 내부 클럭을 외부 기준(크리스털 등)에 맞춰 **주파수를 안정화·승수**하는 회로.
- **코드에서:** `ICM20948_CLKSEL_PLL`(0x01) = 클럭 소스로 **PLL 선택**. 센서 내부에서 더 정밀하고 안정된 클럭을 쓰기 위한 옵션.

---

### 핀 연결 (VIN, GND, SDA, SCL만 연결했을 때)

- **최소 I2C:** VIN, GND, SDA, SCL 네 가닥. SDA/SCL에는 3.3V 풀업 필요(많은 브레이크아웃에 내장).
- **AD0:** I2C **주소 선택** 핀. GND → 0x68, VDD → 0x69. 연결 안 하면 보드에서 GND/VDD로 묶어 둔 경우가 많아서 4가닥만으로 동작할 수 있음. 통신이 안 되면 AD0을 GND(0x68) 또는 VDD(0x69)로 명확히 연결.
- **nCS(CS):** I2C 모드일 때는 보통 VDD에 묶어 비활성화(대부분 보드 기본 처리).
- **코드:** 0x68 먼저 시도, 실패하면 0x69 시도 → AD0을 연결하지 않아도 두 주소 중 하나로 동작하도록 되어 있음.

---

### EXT_SLV_SENS_DATA_00 (0x3B) — "마그 데이터가 여기 들어옴"

- **의미:** ICM20948 **내부 I2C 마스터**가 AK09916에서 **읽어 온 데이터**를 저장하는 **버퍼의 시작 주소**.
- **동작 순서:**
  1. STM32가 Bank3에서 SLV0로 "AK09916 레지스터 0x10(ST1)부터 8바이트 읽어라" 설정.
  2. ICM20948 내부 마스터가 AK09916과 I2C 통신 후, 받은 8바이트를 **자기 내부 버퍼**에 저장.
  3. 그 버퍼가 Bank0의 **0x3B(EXT_SLV_SENS_DATA_00)** 부터 0x42까지.
  4. STM32는 ICM20948의 **0x3B부터 8바이트**를 I2C로 읽으면 → 그게 "마그 센서를 읽은 결과".
- **정리:** "마그 데이터가 여기 들어옴" = 내부 마스터가 마그에서 읽은 결과가 0x3B~에 저장된다는 뜻. 마그 센서를 읽고, 그 읽은 데이터가 여기(0x3B~)에 들어간다고 이해하면 됨.


-----------------------------------------------------------------------------------------

### 추가로 더 공부를 해야하는것
- 원시 LSB 카운트
- I2C읽기 쓰기 주소 그냥 주소 활성화랑 쓰기 보낼 때
- dps, FSR(센서가 측정 할 수 있는 최대 범위(+-값) 근데 최대? 개념 물어보기

### 📋 **데이터시트 볼 때 유심히 봐야하는 것**

1. 핀맵(몇 번 핀이 뭐 하는 핀이다”만 정리한 것.), 서킷(회로도)(이 칩을 어떻게 배선하면 되는지” 보여주는 연결도/참고 회로를 가리킵니다.)
2. 이핀은 플옵을 달아라

3. 통신개념 I2C, SPI
4. 통신 속도
5. 통신 규격(타이밍) 언제동안에 us값으로 받아야한다 이런거

6. 레지스터 주소, I2C 각 칩마다 주소값

> **이 모든걸 데이터시트 보면서 하나씩 하나씩 해나가야한다.**