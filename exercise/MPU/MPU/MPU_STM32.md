# ©️ **STM32 MPU9250코드 분석!**

### **MPU9250 주소 값**
```C
// MPU9250 I2C 주소
#define MPU9250_ADDR    0xD0  // 7-bit 주소 0x68, Write = 0xD0, Read = 0xD1

// 가속도, 자이로 데이터 레지스터 주소
#define ACCEL_XOUT_H    0x3B        // 가속계 X축 주소값
#define ACCEL_YOUT_H    0x3D        // 가속계 Y축 주소값
#define ACCEL_ZOUT_H    0x3F        // 가속계 Z축 주소값
#define GYRO_XOUT_H     0x43        // 자이로 X축 주소값
#define GYRO_YOUT_H     0x45        // 자이로 Y축 주소값
#define GYRO_ZOUT_H     0x47        // 자이로 Z축 주소값
```
이거 관한 뜻!



### **I2C 문법**
```C
I2C_HandleTypeDef hi2c1;
```
1. Instance: 사용되는 I2C 하드웨어 모듈을 가리킵니다. 예를 들어, I2C1, I2C2 등.
```c
hi2c1.Instance = I2C1;
```
2. `Init`: I2C 모듈을 초기화할 때 사용하는 설정 구조체입니다. 이 구조체 안에는 통신 속도, 아주소 모드, 송수신 핀 설정, 타임아웃 값 등 I2C에 필요한 다양한 초기화 정보가 담깁니다. 예를 들어:
```c
hi2c1.Init.ClockSpeed = 100000;   // 100kHz
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;  // 50% Duty Cycle
hi2c1.Init.OwnAddress1 = 0x30;    // I2C 슬레이브 주소
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;  // 7비트 주소 모드
```

3. `ErrorCode`: I2C 통신 중 발생한 오류를 기록하는 변수입니다. 오류 코드 값을 확인해서 디버깅할 수 있습니다.
```c
uint32_t error = hi2c1.ErrorCode;
```

4. `State`: I2C의 현재 상태를 나타냅니다. 예를 들어, `HAL_I2C_STATE_READY`, `HAL_I2C_STATE_BUSY`, `HAL_I2C_STATE_ERROR` 등으로 상태를 추적할 수 있습니다.

### **예시 코드**
```c
#include "stm32f4xx_hal.h"

// I2C 핸들러 정의
I2C_HandleTypeDef hi2c1;

// I2C 초기화 함수
void I2C_Init(void)
{
    // I2C1 초기화 설정
    hi2c1.Instance = I2C1;
    hi2c1.Init.ClockSpeed = 100000;          // 100kHz(기본)
    hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;  // 50% Duty Cycle
    hi2c1.Init.OwnAddress1 = 0x30;           // I2C 슬레이브 주소
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;  // 7비트 주소 모드
    hi2c1.Init.EnableDualAddressMode = I2C_DUALADDRESS_DISABLE;  // 이중 주소 비활성화
    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; // 일반 호출 비활성화
    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; // 노스트레치 비활성화

    if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
        // 오류 처리
        Error_Handler();
    }
}

// I2C 송수신 예시 (데이터 보내기)
HAL_StatusTypeDef I2C_Transmit(uint8_t address, uint8_t* data, uint16_t size)
{
    return HAL_I2C_Master_Transmit(&hi2c1, address, data, size, 1000);  // 1초 타임아웃
}
```

### **I2C 핸들러 사용**
- `hi2c1` 변수는 I2C1에 대한 설정을 다루고 있습니다. 다른 I2C 인터페이스를 사용하려면 `hi2c1` 대신 `hi2c2`와 같이 다른 핸들러를 선언하고 초기화할 수 있습니다.
- `HAL_I2C_Init(&hi2c1)` 함수는 I2C 설정을 초기화하고, `HAL_I2C_Master_Transmit()`은 데이터를 송신하는 데 사용됩니다.

### 🤔 **핸들러의 뜻이 뭐야?**
> 컴퓨터 프로그래밍에서 특정 작업이나 이벤트를 처리하는 기능을 가진 함수나 객체를 의미합니다        <br>
> 어떤 작업이 발생했을 때 그 작업을 처리해주는 "처리자" 역할을 하는 것입니다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### **함수구조**
```c
HAL_StatusTypeDef I2C_Read(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t len)
{
    return HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, len, HAL_MAX_DELAY);
}
```
- 위에 있는 문법들에 대해서 알아보자!

### **파라미터 설명**
1. `devAddr`:
    - I2C 장치의 슬레이브 주소입니다. 읽으려는 I2C 장치의 주소를 지정해야 합니다. 이 주소는 7비트 주소로 설정되어야 합니다.

2. `regAddr`:
    - 레지스터 주소입니다. I2C 장치에서 데이터를 읽고자 하는 특정 레지스터의 주소를 설정합니다. 예를 들어, 센서에서 특정 값을 읽으려면 그 값이 저장된 레지스터 주소를 설정합니다.

3. `data`:
    - 데이터를 읽어올 **버퍼(배열)**입니다. I2C 장치에서 읽은 데이터를 저장할 메모리 공간을 제공해야 합니다. 이 배열에는 지정한 길이만큼의 데이터가 저장됩니다.

4. `len`:
    - 읽을 데이터의 길이입니다. 읽어올 바이트 수를 설정합니다. 예를 들어, 2바이트의 데이터를 읽고 싶다면 len을 2로 설정합니다.


```c
HAL_StatusTypeDef HAL_I2C_Mem_Read(
    I2C_HandleTypeDef *hi2c,   // I2C 핸들러
    uint16_t DevAddress,       // I2C 슬레이브 주소 (7bit 주소 << 1)
    uint16_t MemAddress,       // 읽을 메모리 주소 (레지스터 주소)
    uint16_t MemAddSize,       // 메모리 주소 크기 (1바이트/2바이트)(I2C_MEMADD_SIZE_8BIT 또는 I2C_MEMADD_SIZE_16BIT)(uint8_t = 1Byte, uint16_t = 2Byte)
    uint8_t *pData,            // 읽은 데이터를 저장할 버퍼
    uint16_t Size,             // 읽을 데이터 길이(읽을 바이트 수)
    uint32_t Timeout           // 타임아웃 값(ms)
);
```

### **주요 파라미터 설명**

1. `hi2c`:
    - 사용하려는 I2C 핸들러입니다. 여기서는 `&hi2c1`로 설정되어, I2C1 하드웨어 모듈을 사용합니다.

2. `DevAddress`:
    - I2C 장치의 슬레이브 주소입니다. 예를 들어, `devAddr`에 0x68을 설정하면, I2C 주소가 0x68인 장치에서 데이터를 읽습니다.

3. `MemAddress`:
    - 데이터를 읽고자 하는 레지스터 주소입니다. `regAddr` 파라미터가 이 역할을 합니다.

4. `MemAddSize`:
    - 메모리 주소 크기입니다. I2C 장치가 8비트 또는 16비트 주소를 사용하는지에 따라 1 또는 2로 설정할 수 있습니다. 여기서는 1로 설정되어 8비트 주소를 사용한다고 지정한 것입니다.

5. `pData`:
    - 데이터를 읽을 버퍼입니다. 읽은 데이터를 저장할 메모리 공간으로, `data` 배열이 이 역할을 합니다.

6. `Size`:
    - 읽을 데이터의 길이입니다. 예를 들어, `len`을 2로 설정하면 2바이트 데이터를 읽습니다.

7. `Timeout`:
    - I2C 통신에서 타임아웃 시간을 설정하는 값입니다. 여기서는 `HAL_MAX_DELAY`가 설정되어, 타임아웃을 무한 대기하도록 설정됩니다.
    - STM32 HAL 라이브러리에서 사용되는 상수로, 주로 타임아웃 시간을 설정할 때 사용됩니다.
    - 특정 함수가 타임아웃 없이 완료될 때까지 계속 기다리도록 설정하는 역할을 합니다.
    - 0xFFFFFFFF로 정의되어 있습니다. 즉, 32비트 부호 없는 정수의 최대값입니다. 이 값이 타임아웃 파라미터에 전달되면, 해당 함수는 "무한 대기" 상태로 작동하여, 특정 조건이 충족될 때까지 타임아웃을 고려하지 않습니다.
    
    ### **왜 사용할까요?**
    `HAL_MAX_DELAY`는 대개 다음과 같은 상황에서 사용됩니다:
    1. **정확한 타임아웃 값이 필요 없을 때:**
        - 예를 들어, 장치와의 통신에서 데이터가 반드시 읽혀야 하는 경우, 혹은 통신이 중단될 가능성이 낮거나, 시간을 오래 기다려도 괜찮을 때 사용합니다.

    2. **타임아웃 처리가 필요 없는 경우:**
        - 타임아웃을 설정할 필요가 없거나, 타임아웃을 무시하고 계속 기다려야 하는 경우 HAL_MAX_DELAY를 사용하여 무한 대기하도록 할 수 있습니다.

    #### **주의사항**
    - 타임아웃이 없는 경우: `HAL_MAX_DELAY`를 사용하면 무한 대기 상태가 되기 때문에, 만약 I2C 통신에 문제가 생기거나 장치가 응답하지 않는다면 시스템이 멈추거나 응답하지 않을 수 있습니다. 따라서 이 값을 사용하는 경우, 시스템의 안전성을 보장하려면 다른 방법으로 문제를 감지하고 처리하는 로직을 고려해야 합니다.
    - 적절한 타임아웃 설정: 만약 통신에 시간 제한을 두고 싶다면 `HAL_MAX_DELAY` 대신에 적절한 값을 설정하여 타임아웃을 설정할 수 있습니다. 예를 들어, 1000ms(1초)로 설정하려면 `1000`을 사용할 수 있습니다.

    ```c
    uint8_t data[10];
    uint8_t devAddr = 0x68;  // I2C 슬레이브 주소
    uint8_t regAddr = 0x3B;  // 읽을 레지스터 주소

    // 타임아웃 1초로 설정 (1000 밀리초)
    HAL_StatusTypeDef status = HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, 6, 1000);
    if (status == HAL_OK) {
        // 데이터 읽기 성공
    } else {
        // 오류 처리
    }
    ```
    - 여기서 타임아웃을 `1000`으로 설정하면 1초 동안 기다리고, 그 이후에는 타임아웃 오류를 반환하게 됩니다.

<br>

### 🤔 **근데 왜 ioc에서 설정할 때도 Primary Address Length selection 여기부분에서 7-bit로 설정을 했거든 devAddr 이거 7비트로 해야하는 이유가 있어??
> devAddr (슬레이브 주소)를 7비트로 설정해야 하는 이유는 I2C 주소 규격에 따라 7비트 주소가 표준으로 정의되었기 때문입니다.

1. **I2C 주소 규격**        <br>
I2C 프로토콜에서는 **7비트 주소 체계**와 **10비트 주소 체계** 두 가지를 지원합니다. 하지만 대부분의 I2C 장치에서는 7비트 주소를 사용합니다. 이 이유는 다음과 같습니다:
- **7비트 주소 체계**는 I2C 장치의 주소를 **0~127** 범위 내에서 할당합니다.
- **10비트 주소 체계**는 주소 범위가 **0~1023**으로 확장되지만, 이 체계는 드물게 사용됩니다.

대부분의 I2C 장치는 **7비트 주소 체계**를 따르며, **7비트 주소는 하드웨어의 주소 지정 규격**에 맞춰야 합니다.

<br>

### 🤔 **regAddr 이거는 레지스터 주소라고 했는데 레지스터 주소가 뭐야?? GPIO를 뜻하는건가?**
> 레지스터 주소(regAddr)는 **I2C 장치나 다른 마이크로컨트롤러의 주변 장치(peripheral)**에서 <br>
> 데이터를 읽거나 쓰기 위해 접근하는 특정 메모리 위치를 의미합니다.                 <br>
> 하지만, GPIO와 같은 하드웨어 모듈을 뜻하는 것은 아니고,                           <br>
> I2C 장치(예: 센서, 액추에이터 등) 내에서 특정 데이터를 저장하는 공간을 가리킵니다.    

1. **I2C 장치의 레지스터 주소**     <br>
I2C 장치나 마이크로컨트롤러의 주변 장치들이 내부에 **레지스터(register)**라는 메모리 공간을 가지고 있습니다.    <br>
이 레지스터들은 장치가 동작하는 데 필요한 설정 값이나 측정된 데이터 등을 저장하는 공간입니다.       <br>
예를 들어, 센서에서는 온도 데이터나 가속도 데이터가 각기 다른 레지스터에 저장됩니다.        


### **레지스터의 구성:**
- **물리적 장치 내에 위치:** I2C 장치(예: 센서, 디스플레이 등)의 내부에 레지스터들이 물리적으로 존재합니다.
- **규격이 정의되어 있음:** 각 I2C 장치마다 레지스터 주소가 규격에 따라 정의되어 있습니다. 즉, 어떤 주소에 온도 값이 저장된다거나 어떤 주소에 가속도 데이터가 저장된다는 것이 사전에 정의되어 있는 것입니다.

#### **예시: MPU6050 센서 (가속도계 + 자이로)**
예를 들어, MPU6050 센서의 레지스터 주소는 데이터시트에 명시되어 있습니다.           <br>
이 장치는 I2C 통신을 통해 데이터를 송수신하는데, 각 센서의 데이터는 고유한 레지스터 주소에 저장됩니다.
- 0x3B 주소는 가속도 데이터(X축)를 저장하는 레지스터입니다.
- 0x43 주소는 자이로 데이터(X축)를 저장하는 레지스터입니다.

이런 주소들은 하드웨어 장치에 의해 하드웨어적으로 정의된 것이기 때문에,             <br>
프로그램에서 이 주소를 통해 해당 데이터를 읽어오는 방식으로 통신이 이루어집니다.

### **I2C 장치에서 레지스터 주소**
I2C 통신에서 레지스터 주소는 물리적 장치 내의 특정 메모리 주소입니다.               <br>
예를 들어, 센서에서 온도를 측정하고 그 값을 특정 레지스터 주소에 저장하는 방식입니다.           <br>
 이를 프로그래밍적으로 접근하려면, 해당 장치의 레지스터 주소를 알아야 하고, 그 주소를 통해 데이터를 읽거나 쓸 수 있습니다.

2. **C 언어의 register 키워드**                             <br>
C 언어에서 register는 변수 저장 위치에 관한 제어를 위해 사용되는 키워드입니다.  <br>
이 키워드는 변수가 레지스터(CPU 내부의 고속 메모리)에 저장되도록 요청하는 역할을 합니다.
- register 변수는 컴파일러에게 가능한 한 레지스터에 변수 값을 저장하도록 최적화하라고 지시하는 것입니다. 레지스터에 저장된 변수는 메모리보다 빠르게 접근할 수 있기 때문에 성능을 향상시킬 수 있습니다.

### **C 언어의 register와 하드웨어 레지스터의 차이**
- C 언어의 register: 이것은 변수의 저장 위치를 제어하는 것입니다. 컴파일러가 변수에 대한 접근을 최적화하려 할 때 사용됩니다. 그러나 register는 실제 CPU 레지스터에 저장하는 것이 보장되지 않습니다. 현대의 컴파일러는 이 지시를 무시할 수도 있고, 실제로 변수를 메인 메모리에 저장할 수도 있습니다.
- I2C 장치의 레지스터: 이는 하드웨어 장치 내에서 데이터를 읽고 쓰는 주소 공간을 의미합니다. 이 레지스터들은 물리적인 메모리 위치로, I2C 장치의 내부에서 특정 데이터를 저장하는 역할을 합니다.

따라서, C 언어의 register와 하드웨어 장치의 레지스터는 전혀 다른 개념입니다. 하나는 프로그래밍 최적화와 관련된 키워드이고, 다른 하나는 하드웨어 장치의 데이터 저장 공간을 의미합니다.

3. **레지스터 주소의 예시**
I2C 장치에서 데이터가 레지스터 주소에 저장된다고 했을 때, 예를 들어 MPU6050 센서가 온도 데이터를 읽는 방법은 다음과 같습니다:
- MPU6050의 데이터시트에 따르면, 온도 값은 레지스터 0x41과 0x42에 저장됩니다.
- 0x41은 온도의 상위 바이트, 0x42는 온도의 하위 바이트로 나누어져 있습니다.
- I2C 마스터(예: STM32)가 0x41과 0x42 레지스터에서 데이터를 읽어오면, 센서의 온도 값을 계산할 수 있습니다.
```c
uint8_t devAddr = 0x68;      // MPU6050 장치의 슬레이브 주소
uint8_t regAddr = 0x41;      // 온도 데이터 상위 바이트 레지스터 주소
uint8_t data[2];             // 읽을 데이터 배열

HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, 2, HAL_MAX_DELAY);
int16_t temperature = (data[0] << 8) | data[1];  // 상위/하위 바이트를 결합하여 온도 값 계산
```
위 코드에서 regAddr = 0x41은 온도 데이터를 저장하는 레지스터 주소입니다. I2C를 통해 이 주소에서 데이터를 읽고, 두 바이트를 결합하여 실제 온도 값을 계산할 수 있습니다.

----------------------------------------------------------------------------------------------------------------------------

### **전체 흐름**

1. **슬레이브 주소(devAddr)**와 **레지스터 주소(regAddr)**를 사용하여, 마스터가 읽고자 하는 슬레이브 장치의 특정 레지스터를 지정합니다.
2. `HAL_I2C_Mem_Read()` 함수가 I2C 버스를 통해 해당 장치에 읽기 명령을 보냅니다.
3. 슬레이브 장치는 해당 레지스터에서 데이터를 읽어서 `data` 배열에 저장합니다.
4. 읽은 데이터는 지정된 `len`만큼 `data` 배열에 저장됩니다.

```C
uint8_t data[10];   // 읽어올 데이터를 저장할 배열
uint8_t devAddr = 0x68;  // I2C 장치 주소 (예: 0x68, MPU6050 센서)
uint8_t regAddr = 0x3B;  // 읽을 레지스터 주소 (예: 0x3B, 가속도 데이터)

HAL_StatusTypeDef status = I2C_Read(devAddr, regAddr, data, 6);  // 6바이트 데이터 읽기
if (status == HAL_OK) {
    // 데이터 읽기 성공
    // data 배열에 6바이트의 데이터가 저장됩니다.
} else {
    // 오류 처리
}
```

### `HAL_StatusTypeDef` **내부 구조!**
```c
// STM32 HAL 라이브러리의 상태 코드 정의

// HAL_StatusTypeDef는 typedef로 정의된 32비트 정수형 값입니다.
typedef uint32_t HAL_StatusTypeDef;

// HAL 상태 코드 상수 정의
#define HAL_OK           ((HAL_StatusTypeDef)0x00)  // 작업 성공
#define HAL_ERROR        ((HAL_StatusTypeDef)0x01)  // 오류 발생
#define HAL_BUSY         ((HAL_StatusTypeDef)0x02)  // 장치가 바쁨
#define HAL_TIMEOUT      ((HAL_StatusTypeDef)0x03)  // 타임아웃 발생
```

### 🤔 **어? 근데 그러면 저거 I2C_Read() 이거 왜 한거야??**
- 일단 `I2C_Read` 이거 왜 했는지 알기전에 WHO_AM_I 레지스터에 대해서 알아보자!

### **WHO_AM_I 레지스터란?**
- 목적: WHO_AM_I 레지스터는 센서나 하드웨어 장치가 자신을 식별하는 값을 제공합니다. 이를 통해, 센서가 정상적으로 연결되었는지, 통신이 올바르게 이루어졌는지 확인할 수 있습니다.
- 동작 방식: 각 I2C 장치나 센서는 고유한 식별값을 가진 WHO_AM_I 레지스터를 제공합니다. 예를 들어, MPU9250 센서는 WHO_AM_I 레지스터에서 0x71 값을 반환하고, 다른 센서나 장치들은 각각 다른 고유 값을 반환합니다.

> 사실 말은 이렇게 하지만 아까 우리가 봤던 레지스터 주소값이라고 생각하면 됌

### `0x75` **레지스터와 `0x71` 값**
- **레지스터 주소 0x75**는 MPU9250에서 WHO_AM_I 레지스터의 주소입니다. 이 레지스터는 센서 고유의 ID 값을 반환합니다.
- MPU9250 센서의 WHO_AM_I 레지스터의 값은 **0x71**로 정의되어 있습니다. 즉, 센서가 정상적으로 연결되고, 동작 중일 때 **0x71**을 반환합니다.

### `I2C_Read(MPU9250_ADDR, 0x75, &check, 1);`:
- 0x75 주소에서 WHO_AM_I 레지스터 값을 읽어옵니다.
- 읽은 값은 check 변수에 저장됩니다.

### `if (check == 0x71)`:
- 읽은 값이 **0x71**인지 비교합니다.
- 만약 값이 **0x71**이라면, 센서가 정상적으로 연결된 것으로 판단하여 이후 초기화 작업을 진행합니다.

### **왜 0x71인가?**
MPU9250 센서에서는 WHO_AM_I 레지스터의 값으로 **0x71을 반환합니다. 이 값은 MPU9250 고유의 식별자이기 때문에, 이 값을 통해 정상적인 센서 연결 여부를 확인할 수 있습니다.
- 0x75 주소는 WHO_AM_I 레지스터의 주소입니다.
- **0x71**은 MPU9250에서 이 레지스터에 대한 응답값으로 항상 반환되는 값입니다.

따라서, check == 0x71은 센서가 올바르게 연결되어 있고, 응답을 정상적으로 받았다는 것을 확인하는 역할을 합니다.

### **결론**
- 0x75: MPU9250 센서에서 WHO_AM_I 레지스터의 주소입니다.
- 0x71: MPU9250 센서가 정상적으로 연결되었을 때 WHO_AM_I 레지스터에서 반환되는 고유 ID 값입니다.

코드에서 이 값을 비교하여, 센서가 정상적으로 동작하는지 확인하고, 그 이후 초기화 작업을 진행하는 것입니다.

----------------------------------------------------------------------------------------------------------------------------------------------------

### `HAL_I2C_Mem_Write()` **알아보자!**
`HAL_I2C_Mem_Write()` **함수 개요**
- `HAL_I2C_Mem_Write()`는 STM32 HAL 라이브러리에서 제공하는 함수로, I2C 장치의 메모리에 데이터를 쓰는 작업을 처리합니다. 
- 이 함수는 I2C 마스터가 슬레이브 장치에 데이터를 기록할 때 사용됩니다.

함수 시그니처
```c
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c,
                                     uint16_t DevAddress,
                                     uint16_t MemAddress,
                                     uint16_t MemAddSize,
                                     uint8_t *pData,
                                     uint16_t Size,
                                     uint32_t Timeout);
```

#### **함수 파라미터 설명**
`hi2c`: I2C 핸들러 (I2C_HandleTypeDef 구조체)입니다. I2C 통신을 관리하는 핸들러를 전달합니다. 이 핸들러는 통신에 필요한 설정 정보를 담고 있습니다.      <br>
`DevAddress`: I2C 슬레이브 장치의 주소입니다. 예를 들어, 0x68(MPU9250)와 같이 7비트 주소를 사용합니다.                                          <br>
`MemAddress`: 장치의 메모리 주소입니다. 데이터를 쓸 위치를 지정하는 주소입니다. 예를 들어, 0x6B는 MPU9250의 전원 관리 레지스터(PWR_MGMT_1) 주소입니다.      <br>
`MemAddSize`: 메모리 주소의 크기를 지정하는 값입니다. 보통 1, 2 또는 4바이트로 설정됩니다. (예: 1이면 1바이트 메모리 주소를 사용)       <br>   
`pData`: 쓰기 데이터입니다. I2C 장치의 메모리에 쓸 데이터를 담고 있는 버퍼입니다.           <br>
`Size`: 쓰기 데이터의 크기입니다. 버퍼에 담겨 있는 데이터의 길이를 지정합니다.              <br>
`Timeout`: 타임아웃 시간입니다. I2C 통신이 완료될 때까지 기다릴 시간(밀리초)을 지정합니다.

#### **동작 방식**
`HAL_I2C_Mem_Write()`는 I2C 마스터가 지정된 슬레이브 장치의 메모리 주소에 데이터를 기록하는 함수입니다. 아래는 그 동작 과정입니다:

1. **슬레이브 주소 전송**: 먼저, 슬레이브 장치 주소와 메모리 주소를 전송합니다.
2. **데이터 전송**: 메모리 주소를 정한 뒤, 실제 데이터를 전송합니다.
3. **응답 대기**: 데이터를 전송하고 나면, I2C 마스터는 슬레이브의 응답을 기다립니다.

### `HAL_I2C_Mem_Write()`와 `HAL_I2C_Mem_Read()`의 차이점
- `HAL_I2C_Mem_Read()`: 장치의 메모리에서 데이터를 읽어오는 함수입니다.
- `HAL_I2C_Mem_Write()`: 장치의 메모리에 데이터를 쓰기 위한 함수입니다.

### **I2C 통신의 읽기와 쓰기**
- **읽기**: 마스터는 슬레이브 장치의 메모리에서 데이터를 요청하고, 슬레이브는 그 데이터를 반환합니다.
- **쓰기**: 마스터는 슬레이브 장치의 메모리에 데이터를 전달하고, 슬레이브는 그 값을 메모리에 기록합니다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### **핵심 한 줄 요약**

`(data[0] << 8 | data[1])` 는       <br>
👉 **센서가 16비트 데이터를 8비트씩 나눠서(상위바이트/하위바이트) 보내기 때문에, 다시 하나의 16비트 값으로 합치는 과정이야.**

가속도든 자이로든 **원리는 완전히 동일해.**

### **MPU9250이 데이터를 주는 방식 (중요 ⭐)**
MPU9250 데이터시트 보면 이렇게 되어 있어:

| **축 (Axis)** | **상위 레지스터 (H)** | **하위 레지스터 (L)** | **주소 (HEX)** | **데이터 타입** |
| :--- | :--- | :--- | :--- | :--- |
| **X-Axis** | ACCEL_XOUT_H | ACCEL_XOUT_L | 0x3B / 0x3C | int16_t |
| **Y-Axis** | ACCEL_YOUT_H | ACCEL_YOUT_L | 0x3D / 0x3E | int16_t |
| **Z-Axis** | ACCEL_ZOUT_H | ACCEL_ZOUT_L | 0x3F / 0x40 | int16_t |

- `_H`: **상위 8비트 (MSB)**
- `_L` : **하위 8비트 (LSB)**
- 실제 값은 **signed 16-bit (2’s complement)**

즉, 예를 들면 X축 가속도는:
```css
[ACCEL_XOUT_H][ACCEL_XOUT_L]
```
이렇게 **2바이트로 쪼개**서 들어와.

### **왜 `<< 8`을 하냐?**
예시로 실제 숫자 하나 만들어보자.
```c
data[0] = 0x12;  // 상위 바이트
data[1] = 0x34;  // 하위 바이트
```
이 두 개는 원래 하나의 값:
```
0x1234
```
1️⃣ `data[0] << 8`
```c
0x12 << 8 = 0x1200
```
상위 바이트를 **16비트 공간의 위쪽으로 이동**시키는 거야.

2️⃣ `| data[1]`
```c
0x1200 | 0x34 = 0x1234
```
하위 바이트를 아래쪽에 붙임.

➡️ 결과: **완성된 16비트 값**

### **왜 OR 연산자 `|`를 쓰지? + 말고?**
사실 `+`를 써도 결과는 같아:
```c
(data[0] << 8) + data[1]
```
근데 |를 쓰는 이유는:
- 비트 단위로 “합친다”는 의미가 명확
- 임베디드/드라이버 코드에서 관례적
- 오버플로 걱정도 없음

그래서 **드라이버 코드에서는 거의 무조건 `|` 를 써.**

### **왜 `int16_t`로 캐스팅해?**
MPU9250 가속도/자이로 값은:
- **부호 있음 (signed)**
- 음수 가능 (예: -1g, -250 dps)

예를 들어:
```scss
0xFF38  →  -200 (2’s complement)
```
그래서:
```c
(int16_t)(data[0] << 8 | data[1])
```
이렇게 해야         <br>
👉 **자동으로 음수/양수 해석이 정상적으로 됨**

### **가속도랑 자이로가 같은 이유**
- ✔ 가속도: 16비트 signed
- ✔ 자이로: 16비트 signed
- ✔ 레지스터 구조 동일
- ✔ 빅엔디안(MSB 먼저)

그래서 **코드 패턴이 100% 똑같은 것**이야.

### **한 단계 더 나가면 (다음 레벨 🔥)**
이 값을 실제 물리량으로 쓰려면:
```c
float accel_g = accel_raw / 16384.0f;   // ±2g 설정 시
float gyro_dps = gyro_raw / 131.0f;     // ±250 dps 설정 시
```
이 숫자들은 **FS_SEL / AFS_SEL 설정값**에 따라 바뀌고       <br>
👉 이것도 전부 **데이터시트에 있음**

<br>

### 🤔 **근데 상위비트랑 하위비트를 꼭 나눠야해? 그리고 상위비트가 뭐야? 하위비트는 또 뭐고?
### 1️⃣ **왜 굳이 나눠서 보내냐? (핵심 이유)**
#### **이유 한 줄**
👉 **I2C / SPI는 기본 단위가 8비트(1바이트)이기 때문**이야.

MPU9250 내부에서는 가속도/자이로 값을 **16비트 숫자**로 계산해.     <br>
근데 문제는:
- 한 번에 보내는 최소 단위 = 8비트
- 16비트 = 8비트 × 2

그래서 어쩔 수 없이 이렇게 쪼개서 보냄:
```css
[상위 8비트] [하위 8비트]
```
이건 MPU9250만 그런 게 아니라       <br>
👉 **모든 MCU, 모든 센서, 모든 통신에서 다 똑같음**

<br>

### 2️⃣ **상위 비트(MSB) / 하위 비트(LSB)가 뭐냐?**
#### **숫자를 비트로 쪼개서 보자**
예를 들어 숫자 **1000 (10진수)**

이걸 2진수로 바꾸면:
```yaml
0000 0011 1110 1000
```
이게 **16비트 숫자**야.

여기서 나누면:
```yaml
상위 8비트(MSB) : 0000 0011
하위 8비트(LSB) : 1110 1000
```
- **MSB (Most Significant Byte)**
→ 값의 “크기와 부호”에 더 큰 영향

- **LSB (Least Significant Byte)**
→ 값의 미세한 부분

<br>

### 3️⃣ **숫자로 확실히 느껴보자**
#### **MPU9250이 이런 값을 냈다고 해보자**
```
실제 가속도 raw 값 = 0x1234
```
이걸 나누면:

| **구분** | **값 (Hex)** | **비고** |
| :--- | :--- | :--- |
| **상위 바이트 (High Byte)** | `0x12` | 데이터의 상위 8비트 |
| **하위 바이트 (Low Byte)** | `0x34` | 데이터의 하위 8비트 |
| **합산된 결과 (16-bit)** | `0x1234` | `(0x12 << 8) \| 0x34` |

I2C로 읽으면:
```c
data[0] = 0x12;   // ACCEL_XOUT_H
data[1] = 0x34;   // ACCEL_XOUT_L
```

<br>

### 4️⃣ **그럼 왜 상위가 먼저 와?**
이건 **센서 설계 규칙(엔디안)** 때문이야.

MPU9250은 **Big-endian** 방식:
```nginx
MSB → LSB 순서
```
그래서 데이터시트에 항상:
```nginx
ACCEL_XOUT_H
ACCEL_XOUT_L
```
이 순서로 있음.

(참고로 STM32 내부는 Little-endian인데,     <br>
👉 **통신 데이터랑 MCU 내부 구조는 별개임)**

<br>

### 5️⃣ **그래서 이 코드가 필요한 거다**
```c
(data[0] << 8 | data[1])
```
이걸 사람말로 풀면:

> **“상위 8비트를 왼쪽(큰 자리)으로 옮기고**        <br>
> **하위 8비트를 아래 자리에 붙여서**           <br>
> **원래 16비트 숫자로 복원해라”**

<br>

### 6️⃣ **비유 하나 더 (현금 비유 💸)**
16비트 숫자 = **만원짜리 + 천원짜리**
- 상위 바이트 = 만원 단위
- 하위 바이트 = 천원 단위
```scss
만원(0x12) → 0x1200
천원(0x34) → 0x0034
합치면 → 0x1234
```

----------------------------------------------------------------------------------------------------------------------------------------------------------

### **마그네트토미터(Magnetometer)**
#### **한 줄 정의**
👉 **자기장(자석 기운)을 측정하는 센서야.**

> **지구 자기장을 이용해서 “어디가 북쪽인지” 알려주는 센서**

그래서 보통:
- 전자 나침반
- 헤딩(방향각)
- yaw 보정

에 쓰임.

### 2️⃣ **마그네토미터는 뭘 측정하냐?**
AK8963 기준:
- X, Y, Z축 **자기장 세기**
- 단위: µT (마이크로 테슬라)
- 지구 자기장 ≈ 25~65 µT

---------------------------------------------------------------------------------------------------------------------------------------------------------------

### 1️⃣ **자이로 / 가속도 vs 마그네토미터 차이**
#### **자이로 / 가속도**
- **칩 내부에서 거의 모든 처리를 끝냄**
- MCU 입장에서는:
    - 전원 켜기
    - 범위 설정
    - X/Y/Z 값 읽기
- 끝

그래서:
```
XOUT_H/L
YOUT_H/L
ZOUT_H/L
```
이 정도면 충분함

<br>

### **마그네토미터 (AK8963)**
얘는 다름 😅
- **지구 자기장 측정**
- 주변:
    - 철
    - 전류
    - PCB
    - 모터
    - 스피커    <br>
        전부 영향 줌

그래서:
- “지금 데이터 유효함?”
- “오버플로우 났나?”
- “측정 중인가?”
- “한 번 측정했나? 연속 측정 중인가?”

👉 이런 걸 **상태 레지스터로 계속 알려줘야 함**

<br>

### 2️⃣ **레지스터 하나씩 보면 별 거 아님**
### 🔹 **WHO_AM_I (0x00)**
```c
#define AK8963_WHO_AM_I 0x00   // 0x48
```
- “나 AK8963 맞아?”
- I2C 통신 살아있는지 확인용

👉 MPU9250이랑 똑같은 개념

### 🔹 **ST1 (0x02) – Status 1**
```c
#define AK8963_ST1 0x02
```
여기 핵심 비트들:
- DRDY: Data Ready
- 1 → 새 데이터 있음
- 0 → 아직 측정 중

⚠️ 마그네토미터는                                       <br>
👉 **DRDY 안 보고 데이터 읽으면 쓰레기 값 나올 수 있음**

### 🔹 **HXL ~ HZH (0x03 ~ 0x08)**
```c
#define AK8963_HXL 0x03
// HXL,HXH,HYL,HYH,HZL,HZH
```
여기서 눈치 챘어야 할 포인트 👀

❗ **L → H 순서(H = 상위비트, L = 하위비트)**
- 가속도 / 자이로: `H → L`
- 마그네토미터: `L → H`

이거 때문에 초보자들 진짜 많이 삽질함 😇

### 🔹 **ST2 (0x09) ← (지금 코드엔 없네)**
```c
#define AK8963_ST2 0x09
```
이게 **진짜 중요한 놈**
- **HOFL (Overflow)** 비트 있음
- 측정 범위 초과하면 1

👉 **ST2 읽지 않으면 다음 데이터 안 갱신됨**        <br>
(데이터시트에 작게 써 있어서 잘 놓침)

-----------------------------------------------------------------------------------------------------------------------------------------

### 🔹 **CNTL1 (0x0A) – 측정 모드**
```c
#define AK8963_CNTL1 0x0A
```
여기서 설정함:
- Power-down
- Single measurement
- Continuous measurement 1 / 2
- 14bit / 16bit 출력

마그네토미터는:                 <br>
👉 **측정 모드를 직접 지정해야 데이터가 나옴**

### 🔹 **CNTL2 (0x0B) – 리셋**
```c
#define AK8963_CNTL2 0x0B
```
- Soft reset
- 캘리브레이션 시 필요

<br>

### 1️⃣ **CNTL1 (0x0A) – 측정 모드가 정확히 뭐냐?**
#### **핵심**
👉 **AK8963에게 “지금부터 어떤 방식으로 자기장을 측정할지”를 지시하는 레지스터**

마그네토미터는 **항상 자동**으로 측정 안 함     <br>
→ **모드를 설정**해야만 실제 측정이 시작돼.

### **CNTL1 비트 구조 (중요 ⭐)**
```scss
[7:4]  Output Bit (해상도)
[3:0]  Measurement Mode
```
📌 **출력 비트 수**
- 0 : 14-bit
- 1 : 16-bit ← 보통 이거 씀

### 📌 **측정 모드 종류**

| **값 (Bit)** | **모드 (Mode)** | **의미 (Description)** |
| :--- | :--- | :--- |
| **`0000`** | **Power-down** | 전원 꺼짐 (대기 상태) |
| **`0001`** | **Single measurement** | 요청 시 1번만 측정 후 휴면 |
| **`0010`** | **Continuous 1** | 연속 측정 모드 1 (8Hz 주기) |
| **`0110`** | **Continuous 2** | 연속 측정 모드 2 (100Hz 주기) |
| **`1111`** | **Fuse ROM access** | 센서 보정값(Sensitivity) 읽기 모드 |

### **예시 코드**
```c
// 16bit + Continuous measurement 2 (100Hz)
I2C_Write(AK8963_ADDR, AK8963_CNTL1, 0x16);
```
👉 이걸 쓰는 순간:
- 센서가 **자동으로 계속 측정**
- ST1.DRDY 주기적으로 1 됨

### **“측정한다”는 게 정확히 뭐냐면**
마그네토미터에서 측정은:
1. 자기장 샘플링
2. 내부 ADC 변환
3. X/Y/Z 레지스터에 저장
4. ST1.DRDY = 1

이 전체 과정을 말함.

<br>

### 2️⃣ **CNTL2 (0x0B) – 리셋이 정확히 뭐냐?**
#### **핵심**
👉 **AK8963 내부 상태를 초기화하는 Soft Reset**
- ❌ “센서 값을 다시 읽는다” 아님
- ⭕ “센서 내부 상태를 처음 상태로 되돌린다”

### **CNTL2 구조**
```pgsql
bit[0] = SRST (Soft Reset)
```

```c
I2C_Write(AK8963_ADDR, AK8963_CNTL2, 0x01);
```
이걸 쓰면:
- 측정 중단
- CNTL1 설정 초기화
- 상태 레지스터 초기화
- 다시 Power-down 상태

👉 **이후엔 반드시 CNTL1을 다시 설정해야 함**

### **언제 리셋을 쓰냐?**
- 전원 불안정했을 때
- Mag 값이 고정돼 버렸을 때
- 캘리브레이션 전
- 초기화 시 한 번

보통:
```c
reset → mode 설정 → 측정 시작
```

### 3️⃣ **측정 모드 vs 리셋, 한 눈에 비교**

| **구분** | **CNTL1** | **CNTL2** |
| :--- | :---: | :---: |
| **역할** | 측정 방식 설정 | 내부 초기화 |
| **데이터 생성** | ⭕ | ❌ |
| **상태 초기화** | ❌ | ⭕ |
| **연속 측정** | ⭕ | ❌ |
| **측정 시작** | ⭕ | ❌ |

<br>

### 4️⃣ **전체 흐름으로 보면 이렇게 됨**
#### **초기화**
```c
// 1. Soft Reset
I2C_Write(AK8963_ADDR, AK8963_CNTL2, 0x01);

// 2. 16bit + Continuous mode
I2C_Write(AK8963_ADDR, AK8963_CNTL1, 0x16);
```
#### **데이터 읽기**
```c
if (ST1 & DRDY) {
    read_mag_xyz();
    read_ST2(); // 필수!
}
```

<br>

### 6️⃣ **한 문장으로 최종 정리** 🔥
- **CNTL1** = “어떻게, 얼마나 자주 측정할지”
- **CNTL2** = “지금 상태 다 지우고 처음부터”
- 리셋 후엔 **반드시 CNTL1 재설정**

<br>

### 3️⃣ **왜 X/Y/Z 말고 절차가 필요하냐면**
#### **자이로 / 가속도**
- “지금 값 바로 줌”
- 내부 필터 / 타이밍 MCU 신경 안 써도 됨

#### **마그네토미터**
- “측정 → 완료 → 읽기 → 플래그 클리어”
- 순서 어기면:
    - 값 고정됨
    - 이전 값 반복
    - 오버플로우 무시

그래서:
1. ST1 확인
2. 데이터 읽기
3. ST2 읽기 (필수)
4. 다음 측정

이 구조가 됨

<br>

### 4️⃣ **왜 MPU9250 안에 들어있는데도 이렇게 귀찮냐?**
중요한 포인트 하나 더 👇

AK8963은:
- MPU9250 내부 I2C 슬레이브
- MPU9250의 자이로/가속도랑 완전히 다른 칩

그래서:
- 레지스터 구조 다름
- 데이터 순서 다름
- 설정 방식 다름

👉 “같은 패키지 안에 들어있을 뿐, 성격은 완전 딴 애”

<br>

### 5️⃣ **한 눈에 정리**

| **구분** | **가속도** / **자이로** | **마그네토미터 (지자기)** |
| :--- | :--- | :--- |
| **물리량** | 관성 | 지구 자기장 |
| **환경 영향** | 적음 | 매우 큼 |
| **상태 체크** | 거의 없음 | 필수 (Calibration 등) |
| **데이터 순서** | `H → L` | `L → H` |
| **측정 모드** | 항상 동작 | 설정 필요 |
| **오버플로우** | 드묾 | 잦음 |

<br>

### 6️⃣ **그래서 보통 드라이버 구조가 이렇게 됨**
```c
if (ST1 & DRDY) {
    read_mag_data();
    read_ST2();   // 필수!
}
```
이 한 줄 때문에 레지스터가 많아 보이는 거야 😄

### **정리 한 줄** 🔥
> **마그네토미터는 “값”이 아니라**          <br>
> **“측정 과정”을 읽는 센서라서 레지스터가 많다**

-------------------------------------------------------------------------------------------------------------------------------------------------------

### **한 문장으로 정리** 🔥
- **마그네토미터** = 지구 자기장 측정 → 나침반
- **H/L** = 상위 / 하위 바이트
- **H → L / L → H** = 센서 설계 차이
- **데이터시트 안 보면 무조건 삽질**

-----------------------------------------------------------------------------------------------------------------------------------------------------

### 🤔 **여기까지 보면서 궁금한게 있는데 왜 MPU9250은 레지스터 시작 주소가 0x68인데 왜 코드에는 0xD0으로 되어 있어??**
### **설명**
I2C 주소는 7비트로 구성되어 있고, 통신 시 **읽기(Read)**와 **쓰기(Write)**에 따라 마지막 비트(LSB, Least Significant Bit)가 달라져. 예를 들어, 0x68 주소를 가지고 있다고 할 때,
- **쓰기:** 7비트 주소는 0x68, 8비트 주소는 0xD0 (7비트 주소 뒤에 0을 붙임)
- **읽기:** 7비트 주소는 0x68, 8비트 주소는 0xD1 (7비트 주소 뒤에 1을 붙임)

### **세부 설명:**
- **7비트 주소:** 0x68 (0110 1000)
- **쓰기 주소 (Write):** 7비트 주소의 마지막에 0을 붙여서 0xD0 (이진수로 11010000)
- **읽기 주소 (Read):** 7비트 주소의 마지막에 1을 붙여서 0xD1 (이진수로 11010001)

따라서 MPU9250_ADDR에서 0xD0은 MPU9250에 데이터를 쓰기 위한 주소이고, 0xD1은 데이터를 읽기 위한 주소인 거지.

### **요약:**
- 0x68은 7비트 주소 (고정 주소)
- 0xD0은 8비트 주소로 쓰기를 위한 값 (0x68 << 1 + 0)
- 0xD1은 8비트 주소로 읽기를 위한 값 (0x68 << 1 + 1)

------------------------------------------------------------------------------------------------------------------------------------------------

### **MPU-9250 주소/레지스터 정리 (코드·공부용)**

| **구분** | **이름** | **주소** | **비고** |
|------|------|------|------|
| **I2C 디바이스 주소** | MPU-9250 (7-bit) | 0x68 (AD0=LOW) / 0x69 (AD0=HIGH) | STM32 HAL은 보통 8-bit 사용: Write=0xD0/0xD2, Read=0xD1/0xD3 (7bit<<1 \| R/W) |
| **자력계 I2C 주소** | AK8963 (슬레이브) | 0x0C | MPU 내부 보조 I2C로 접근. Bypass 모드면 외부 I2C에서 0x0C로 직접 접근 가능 |
| **확인용** | WHO_AM_I | 0x75 | 읽으면 0x71 (MPU-9250), MPU-6500은 0x70 |
| **초기화/설정** | PWR_MGMT_1 | 0x6B | 리셋, 클럭 소스, 슬립 |
| **초기화/설정** | SMPLRT_DIV | 0x19 | 샘플레이트 분주 |
| **초기화/설정** | CONFIG | 0x1A | DLPF 설정 |
| **초기화/설정** | GYRO_CONFIG | 0x1B | 자이로 FSR (±250/500/1000/2000 °/s) |
| **초기화/설정** | ACCEL_CONFIG | 0x1C | 가속도 FSR (±2/4/8/16 g) |
| **Bypass (자력계 직접)** | INT_PIN_CFG | 0x37 | 0x02 쓰면 자력계를 외부 I2C 0x0C로 직접 접근 |
| **데이터** | ACCEL_XOUT_H | 0x3B | 0x3B~0x40 (X,Y,Z 각 2바이트) |
| **데이터** | GYRO_XOUT_H | 0x43 | 0x43~0x48 (X,Y,Z 각 2바이트) |
| **자력계 (보조 I2C)** | I2C_SLV0_ADDR / REG / CTRL 등 | 0x25~0x27, 0x24 등 | Register Map의 Auxiliary I2C 섹션 참고 |

- **데이터시트에서 주소만 보고 싶을 때:**
    - Register Map PDF 를 열고 Register(주소) 열과 Name 열만 대응해서 보면 됩니다.
    - ACCEL_XOUT_H = 0x3B, GYRO_XOUT_H = 0x43 같은 식으로 표에 나옵니다.
이거 관한 뜻!