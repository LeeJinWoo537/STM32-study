# ©️ **STM32 MPU9250코드 분석!**

### **MPU9250 주소 값**
```C
// MPU9250 I2C 주소
#define MPU9250_ADDR    0xD0  // 7-bit 주소 0x68, Write = 0xD0, Read = 0xD1

// 가속도, 자이로 데이터 레지스터 주소
#define ACCEL_XOUT_H    0x3B        // 가속계 X축 주소값
#define ACCEL_YOUT_H    0x3D        // 가속계 Y축 주소값
#define ACCEL_ZOUT_H    0x3F        // 가속계 Z축 주소값
#define GYRO_XOUT_H     0x43        // 자이로 X축 주소값
#define GYRO_YOUT_H     0x45        // 자이로 Y축 주소값
#define GYRO_ZOUT_H     0x47        // 자이로 Z축 주소값
```
이거 관한 뜻!



### **I2C 문법**
```C
I2C_HandleTypeDef hi2c1;
```
1. Instance: 사용되는 I2C 하드웨어 모듈을 가리킵니다. 예를 들어, I2C1, I2C2 등.
```c
hi2c1.Instance = I2C1;
```
2. `Init`: I2C 모듈을 초기화할 때 사용하는 설정 구조체입니다. 이 구조체 안에는 통신 속도, 아주소 모드, 송수신 핀 설정, 타임아웃 값 등 I2C에 필요한 다양한 초기화 정보가 담깁니다. 예를 들어:
```c
hi2c1.Init.ClockSpeed = 100000;   // 100kHz
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;  // 50% Duty Cycle
hi2c1.Init.OwnAddress1 = 0x30;    // I2C 슬레이브 주소
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;  // 7비트 주소 모드
```

3. `ErrorCode`: I2C 통신 중 발생한 오류를 기록하는 변수입니다. 오류 코드 값을 확인해서 디버깅할 수 있습니다.
```c
uint32_t error = hi2c1.ErrorCode;
```

4. `State`: I2C의 현재 상태를 나타냅니다. 예를 들어, `HAL_I2C_STATE_READY`, `HAL_I2C_STATE_BUSY`, `HAL_I2C_STATE_ERROR` 등으로 상태를 추적할 수 있습니다.

### **예시 코드**
```c
#include "stm32f4xx_hal.h"

// I2C 핸들러 정의
I2C_HandleTypeDef hi2c1;

// I2C 초기화 함수
void I2C_Init(void)
{
    // I2C1 초기화 설정
    hi2c1.Instance = I2C1;
    hi2c1.Init.ClockSpeed = 100000;          // 100kHz(기본)
    hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;  // 50% Duty Cycle
    hi2c1.Init.OwnAddress1 = 0x30;           // I2C 슬레이브 주소
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;  // 7비트 주소 모드
    hi2c1.Init.EnableDualAddressMode = I2C_DUALADDRESS_DISABLE;  // 이중 주소 비활성화
    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; // 일반 호출 비활성화
    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; // 노스트레치 비활성화

    if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
        // 오류 처리
        Error_Handler();
    }
}

// I2C 송수신 예시 (데이터 보내기)
HAL_StatusTypeDef I2C_Transmit(uint8_t address, uint8_t* data, uint16_t size)
{
    return HAL_I2C_Master_Transmit(&hi2c1, address, data, size, 1000);  // 1초 타임아웃
}
```

### **I2C 핸들러 사용**
- `hi2c1` 변수는 I2C1에 대한 설정을 다루고 있습니다. 다른 I2C 인터페이스를 사용하려면 `hi2c1` 대신 `hi2c2`와 같이 다른 핸들러를 선언하고 초기화할 수 있습니다.
- `HAL_I2C_Init(&hi2c1)` 함수는 I2C 설정을 초기화하고, `HAL_I2C_Master_Transmit()`은 데이터를 송신하는 데 사용됩니다.

### 🤔 **핸들러의 뜻이 뭐야?**
> 컴퓨터 프로그래밍에서 특정 작업이나 이벤트를 처리하는 기능을 가진 함수나 객체를 의미합니다        <br>
> 어떤 작업이 발생했을 때 그 작업을 처리해주는 "처리자" 역할을 하는 것입니다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### **함수구조**
```c
HAL_StatusTypeDef I2C_Read(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t len)
{
    return HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, len, HAL_MAX_DELAY);
}
```
- 위에 있는 문법들에 대해서 알아보자!

### **파라미터 설명**
1. `devAddr`:
    - I2C 장치의 슬레이브 주소입니다. 읽으려는 I2C 장치의 주소를 지정해야 합니다. 이 주소는 7비트 주소로 설정되어야 합니다.

2. `regAddr`:
    - 레지스터 주소입니다. I2C 장치에서 데이터를 읽고자 하는 특정 레지스터의 주소를 설정합니다. 예를 들어, 센서에서 특정 값을 읽으려면 그 값이 저장된 레지스터 주소를 설정합니다.

3. `data`:
    - 데이터를 읽어올 **버퍼(배열)**입니다. I2C 장치에서 읽은 데이터를 저장할 메모리 공간을 제공해야 합니다. 이 배열에는 지정한 길이만큼의 데이터가 저장됩니다.

4. `len`:
    - 읽을 데이터의 길이입니다. 읽어올 바이트 수를 설정합니다. 예를 들어, 2바이트의 데이터를 읽고 싶다면 len을 2로 설정합니다.


```c
HAL_StatusTypeDef HAL_I2C_Mem_Read(
    I2C_HandleTypeDef *hi2c,   // I2C 핸들러
    uint16_t DevAddress,       // I2C 슬레이브 주소 (7bit 주소 << 1)
    uint16_t MemAddress,       // 읽을 메모리 주소 (레지스터 주소)
    uint16_t MemAddSize,       // 메모리 주소 크기 (1바이트/2바이트)(I2C_MEMADD_SIZE_8BIT 또는 I2C_MEMADD_SIZE_16BIT)(uint8_t = 1Byte, uint16_t = 2Byte)
    uint8_t *pData,            // 읽은 데이터를 저장할 버퍼
    uint16_t Size,             // 읽을 데이터 길이(읽을 바이트 수)
    uint32_t Timeout           // 타임아웃 값(ms)
);
```

### **주요 파라미터 설명**

1. `hi2c`:
    - 사용하려는 I2C 핸들러입니다. 여기서는 `&hi2c1`로 설정되어, I2C1 하드웨어 모듈을 사용합니다.

2. `DevAddress`:
    - I2C 장치의 슬레이브 주소입니다. 예를 들어, `devAddr`에 0x68을 설정하면, I2C 주소가 0x68인 장치에서 데이터를 읽습니다.

3. `MemAddress`:
    - 데이터를 읽고자 하는 레지스터 주소입니다. `regAddr` 파라미터가 이 역할을 합니다.

4. `MemAddSize`:
    - 메모리 주소 크기입니다. I2C 장치가 8비트 또는 16비트 주소를 사용하는지에 따라 1 또는 2로 설정할 수 있습니다. 여기서는 1로 설정되어 8비트 주소를 사용한다고 지정한 것입니다.

5. `pData`:
    - 데이터를 읽을 버퍼입니다. 읽은 데이터를 저장할 메모리 공간으로, `data` 배열이 이 역할을 합니다.

6. `Size`:
    - 읽을 데이터의 길이입니다. 예를 들어, `len`을 2로 설정하면 2바이트 데이터를 읽습니다.

7. `Timeout`:
    - I2C 통신에서 타임아웃 시간을 설정하는 값입니다. 여기서는 `HAL_MAX_DELAY`가 설정되어, 타임아웃을 무한 대기하도록 설정됩니다.
    - STM32 HAL 라이브러리에서 사용되는 상수로, 주로 타임아웃 시간을 설정할 때 사용됩니다.
    - 특정 함수가 타임아웃 없이 완료될 때까지 계속 기다리도록 설정하는 역할을 합니다.
    - 0xFFFFFFFF로 정의되어 있습니다. 즉, 32비트 부호 없는 정수의 최대값입니다. 이 값이 타임아웃 파라미터에 전달되면, 해당 함수는 "무한 대기" 상태로 작동하여, 특정 조건이 충족될 때까지 타임아웃을 고려하지 않습니다.
    
    ### **왜 사용할까요?**
    `HAL_MAX_DELAY`는 대개 다음과 같은 상황에서 사용됩니다:
    1. **정확한 타임아웃 값이 필요 없을 때:**
        - 예를 들어, 장치와의 통신에서 데이터가 반드시 읽혀야 하는 경우, 혹은 통신이 중단될 가능성이 낮거나, 시간을 오래 기다려도 괜찮을 때 사용합니다.

    2. **타임아웃 처리가 필요 없는 경우:**
        - 타임아웃을 설정할 필요가 없거나, 타임아웃을 무시하고 계속 기다려야 하는 경우 HAL_MAX_DELAY를 사용하여 무한 대기하도록 할 수 있습니다.

    #### **주의사항**
    - 타임아웃이 없는 경우: `HAL_MAX_DELAY`를 사용하면 무한 대기 상태가 되기 때문에, 만약 I2C 통신에 문제가 생기거나 장치가 응답하지 않는다면 시스템이 멈추거나 응답하지 않을 수 있습니다. 따라서 이 값을 사용하는 경우, 시스템의 안전성을 보장하려면 다른 방법으로 문제를 감지하고 처리하는 로직을 고려해야 합니다.
    - 적절한 타임아웃 설정: 만약 통신에 시간 제한을 두고 싶다면 `HAL_MAX_DELAY` 대신에 적절한 값을 설정하여 타임아웃을 설정할 수 있습니다. 예를 들어, 1000ms(1초)로 설정하려면 `1000`을 사용할 수 있습니다.

    ```c
    uint8_t data[10];
    uint8_t devAddr = 0x68;  // I2C 슬레이브 주소
    uint8_t regAddr = 0x3B;  // 읽을 레지스터 주소

    // 타임아웃 1초로 설정 (1000 밀리초)
    HAL_StatusTypeDef status = HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, 6, 1000);
    if (status == HAL_OK) {
        // 데이터 읽기 성공
    } else {
        // 오류 처리
    }
    ```
    - 여기서 타임아웃을 `1000`으로 설정하면 1초 동안 기다리고, 그 이후에는 타임아웃 오류를 반환하게 됩니다.

<br>

### 🤔 **근데 왜 ioc에서 설정할 때도 Primary Address Length selection 여기부분에서 7-bit로 설정을 했거든 devAddr 이거 7비트로 해야하는 이유가 있어??
> devAddr (슬레이브 주소)를 7비트로 설정해야 하는 이유는 I2C 주소 규격에 따라 7비트 주소가 표준으로 정의되었기 때문입니다.

1. **I2C 주소 규격**        <br>
I2C 프로토콜에서는 **7비트 주소 체계**와 **10비트 주소 체계** 두 가지를 지원합니다. 하지만 대부분의 I2C 장치에서는 7비트 주소를 사용합니다. 이 이유는 다음과 같습니다:
- **7비트 주소 체계**는 I2C 장치의 주소를 **0~127** 범위 내에서 할당합니다.
- **10비트 주소 체계**는 주소 범위가 **0~1023**으로 확장되지만, 이 체계는 드물게 사용됩니다.

대부분의 I2C 장치는 **7비트 주소 체계**를 따르며, **7비트 주소는 하드웨어의 주소 지정 규격**에 맞춰야 합니다.

<br>

### 🤔 **regAddr 이거는 레지스터 주소라고 했는데 레지스터 주소가 뭐야?? GPIO를 뜻하는건가?**
> 레지스터 주소(regAddr)는 **I2C 장치나 다른 마이크로컨트롤러의 주변 장치(peripheral)**에서 <br>
> 데이터를 읽거나 쓰기 위해 접근하는 특정 메모리 위치를 의미합니다.                 <br>
> 하지만, GPIO와 같은 하드웨어 모듈을 뜻하는 것은 아니고,                           <br>
> I2C 장치(예: 센서, 액추에이터 등) 내에서 특정 데이터를 저장하는 공간을 가리킵니다.    

1. **I2C 장치의 레지스터 주소**     <br>
I2C 장치나 마이크로컨트롤러의 주변 장치들이 내부에 **레지스터(register)**라는 메모리 공간을 가지고 있습니다.    <br>
이 레지스터들은 장치가 동작하는 데 필요한 설정 값이나 측정된 데이터 등을 저장하는 공간입니다.       <br>
예를 들어, 센서에서는 온도 데이터나 가속도 데이터가 각기 다른 레지스터에 저장됩니다.        


### **레지스터의 구성:**
- **물리적 장치 내에 위치:** I2C 장치(예: 센서, 디스플레이 등)의 내부에 레지스터들이 물리적으로 존재합니다.
- **규격이 정의되어 있음:** 각 I2C 장치마다 레지스터 주소가 규격에 따라 정의되어 있습니다. 즉, 어떤 주소에 온도 값이 저장된다거나 어떤 주소에 가속도 데이터가 저장된다는 것이 사전에 정의되어 있는 것입니다.

#### **예시: MPU6050 센서 (가속도계 + 자이로)**
예를 들어, MPU6050 센서의 레지스터 주소는 데이터시트에 명시되어 있습니다.           <br>
이 장치는 I2C 통신을 통해 데이터를 송수신하는데, 각 센서의 데이터는 고유한 레지스터 주소에 저장됩니다.
- 0x3B 주소는 가속도 데이터(X축)를 저장하는 레지스터입니다.
- 0x43 주소는 자이로 데이터(X축)를 저장하는 레지스터입니다.

이런 주소들은 하드웨어 장치에 의해 하드웨어적으로 정의된 것이기 때문에,             <br>
프로그램에서 이 주소를 통해 해당 데이터를 읽어오는 방식으로 통신이 이루어집니다.

### **I2C 장치에서 레지스터 주소**
I2C 통신에서 레지스터 주소는 물리적 장치 내의 특정 메모리 주소입니다.               <br>
예를 들어, 센서에서 온도를 측정하고 그 값을 특정 레지스터 주소에 저장하는 방식입니다.           <br>
 이를 프로그래밍적으로 접근하려면, 해당 장치의 레지스터 주소를 알아야 하고, 그 주소를 통해 데이터를 읽거나 쓸 수 있습니다.

2. **C 언어의 register 키워드**                             <br>
C 언어에서 register는 변수 저장 위치에 관한 제어를 위해 사용되는 키워드입니다.  <br>
이 키워드는 변수가 레지스터(CPU 내부의 고속 메모리)에 저장되도록 요청하는 역할을 합니다.
- register 변수는 컴파일러에게 가능한 한 레지스터에 변수 값을 저장하도록 최적화하라고 지시하는 것입니다. 레지스터에 저장된 변수는 메모리보다 빠르게 접근할 수 있기 때문에 성능을 향상시킬 수 있습니다.

### **C 언어의 register와 하드웨어 레지스터의 차이**
- C 언어의 register: 이것은 변수의 저장 위치를 제어하는 것입니다. 컴파일러가 변수에 대한 접근을 최적화하려 할 때 사용됩니다. 그러나 register는 실제 CPU 레지스터에 저장하는 것이 보장되지 않습니다. 현대의 컴파일러는 이 지시를 무시할 수도 있고, 실제로 변수를 메인 메모리에 저장할 수도 있습니다.
- I2C 장치의 레지스터: 이는 하드웨어 장치 내에서 데이터를 읽고 쓰는 주소 공간을 의미합니다. 이 레지스터들은 물리적인 메모리 위치로, I2C 장치의 내부에서 특정 데이터를 저장하는 역할을 합니다.

따라서, C 언어의 register와 하드웨어 장치의 레지스터는 전혀 다른 개념입니다. 하나는 프로그래밍 최적화와 관련된 키워드이고, 다른 하나는 하드웨어 장치의 데이터 저장 공간을 의미합니다.

3. **레지스터 주소의 예시**
I2C 장치에서 데이터가 레지스터 주소에 저장된다고 했을 때, 예를 들어 MPU6050 센서가 온도 데이터를 읽는 방법은 다음과 같습니다:
- MPU6050의 데이터시트에 따르면, 온도 값은 레지스터 0x41과 0x42에 저장됩니다.
- 0x41은 온도의 상위 바이트, 0x42는 온도의 하위 바이트로 나누어져 있습니다.
- I2C 마스터(예: STM32)가 0x41과 0x42 레지스터에서 데이터를 읽어오면, 센서의 온도 값을 계산할 수 있습니다.
```c
uint8_t devAddr = 0x68;      // MPU6050 장치의 슬레이브 주소
uint8_t regAddr = 0x41;      // 온도 데이터 상위 바이트 레지스터 주소
uint8_t data[2];             // 읽을 데이터 배열

HAL_I2C_Mem_Read(&hi2c1, devAddr, regAddr, 1, data, 2, HAL_MAX_DELAY);
int16_t temperature = (data[0] << 8) | data[1];  // 상위/하위 바이트를 결합하여 온도 값 계산
```
위 코드에서 regAddr = 0x41은 온도 데이터를 저장하는 레지스터 주소입니다. I2C를 통해 이 주소에서 데이터를 읽고, 두 바이트를 결합하여 실제 온도 값을 계산할 수 있습니다.

----------------------------------------------------------------------------------------------------------------------------

### **전체 흐름**

1. **슬레이브 주소(devAddr)**와 **레지스터 주소(regAddr)**를 사용하여, 마스터가 읽고자 하는 슬레이브 장치의 특정 레지스터를 지정합니다.
2. `HAL_I2C_Mem_Read()` 함수가 I2C 버스를 통해 해당 장치에 읽기 명령을 보냅니다.
3. 슬레이브 장치는 해당 레지스터에서 데이터를 읽어서 `data` 배열에 저장합니다.
4. 읽은 데이터는 지정된 `len`만큼 `data` 배열에 저장됩니다.

```C
uint8_t data[10];   // 읽어올 데이터를 저장할 배열
uint8_t devAddr = 0x68;  // I2C 장치 주소 (예: 0x68, MPU6050 센서)
uint8_t regAddr = 0x3B;  // 읽을 레지스터 주소 (예: 0x3B, 가속도 데이터)

HAL_StatusTypeDef status = I2C_Read(devAddr, regAddr, data, 6);  // 6바이트 데이터 읽기
if (status == HAL_OK) {
    // 데이터 읽기 성공
    // data 배열에 6바이트의 데이터가 저장됩니다.
} else {
    // 오류 처리
}
```

### `HAL_StatusTypeDef` **내부 구조!**
```c
// STM32 HAL 라이브러리의 상태 코드 정의

// HAL_StatusTypeDef는 typedef로 정의된 32비트 정수형 값입니다.
typedef uint32_t HAL_StatusTypeDef;

// HAL 상태 코드 상수 정의
#define HAL_OK           ((HAL_StatusTypeDef)0x00)  // 작업 성공
#define HAL_ERROR        ((HAL_StatusTypeDef)0x01)  // 오류 발생
#define HAL_BUSY         ((HAL_StatusTypeDef)0x02)  // 장치가 바쁨
#define HAL_TIMEOUT      ((HAL_StatusTypeDef)0x03)  // 타임아웃 발생
```

### 🤔 **어? 근데 그러면 저거 I2C_Read() 이거 왜 한거야??**
- 일단 `I2C_Read` 이거 왜 했는지 알기전에 WHO_AM_I 레지스터에 대해서 알아보자!

### **WHO_AM_I 레지스터란?**
- 목적: WHO_AM_I 레지스터는 센서나 하드웨어 장치가 자신을 식별하는 값을 제공합니다. 이를 통해, 센서가 정상적으로 연결되었는지, 통신이 올바르게 이루어졌는지 확인할 수 있습니다.
- 동작 방식: 각 I2C 장치나 센서는 고유한 식별값을 가진 WHO_AM_I 레지스터를 제공합니다. 예를 들어, MPU9250 센서는 WHO_AM_I 레지스터에서 0x71 값을 반환하고, 다른 센서나 장치들은 각각 다른 고유 값을 반환합니다.

> 사실 말은 이렇게 하지만 아까 우리가 봤던 레지스터 주소값이라고 생각하면 됌

### `0x75` **레지스터와 `0x71` 값**
- **레지스터 주소 0x75**는 MPU9250에서 WHO_AM_I 레지스터의 주소입니다. 이 레지스터는 센서 고유의 ID 값을 반환합니다.
- MPU9250 센서의 WHO_AM_I 레지스터의 값은 **0x71**로 정의되어 있습니다. 즉, 센서가 정상적으로 연결되고, 동작 중일 때 **0x71**을 반환합니다.

### `I2C_Read(MPU9250_ADDR, 0x75, &check, 1);`:
- 0x75 주소에서 WHO_AM_I 레지스터 값을 읽어옵니다.
- 읽은 값은 check 변수에 저장됩니다.

### `if (check == 0x71)`:
- 읽은 값이 **0x71**인지 비교합니다.
- 만약 값이 **0x71**이라면, 센서가 정상적으로 연결된 것으로 판단하여 이후 초기화 작업을 진행합니다.

### **왜 0x71인가?**
MPU9250 센서에서는 WHO_AM_I 레지스터의 값으로 **0x71을 반환합니다. 이 값은 MPU9250 고유의 식별자이기 때문에, 이 값을 통해 정상적인 센서 연결 여부를 확인할 수 있습니다.
- 0x75 주소는 WHO_AM_I 레지스터의 주소입니다.
- **0x71**은 MPU9250에서 이 레지스터에 대한 응답값으로 항상 반환되는 값입니다.

따라서, check == 0x71은 센서가 올바르게 연결되어 있고, 응답을 정상적으로 받았다는 것을 확인하는 역할을 합니다.

### **결론**
- 0x75: MPU9250 센서에서 WHO_AM_I 레지스터의 주소입니다.
- 0x71: MPU9250 센서가 정상적으로 연결되었을 때 WHO_AM_I 레지스터에서 반환되는 고유 ID 값입니다.

코드에서 이 값을 비교하여, 센서가 정상적으로 동작하는지 확인하고, 그 이후 초기화 작업을 진행하는 것입니다.

----------------------------------------------------------------------------------------------------------------------------------------------------

### `HAL_I2C_Mem_Write()` **알아보자!**
`HAL_I2C_Mem_Write()` **함수 개요**
- `HAL_I2C_Mem_Write()`는 STM32 HAL 라이브러리에서 제공하는 함수로, I2C 장치의 메모리에 데이터를 쓰는 작업을 처리합니다. 
- 이 함수는 I2C 마스터가 슬레이브 장치에 데이터를 기록할 때 사용됩니다.

함수 시그니처
```c
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c,
                                     uint16_t DevAddress,
                                     uint16_t MemAddress,
                                     uint16_t MemAddSize,
                                     uint8_t *pData,
                                     uint16_t Size,
                                     uint32_t Timeout);
```

#### **함수 파라미터 설명**
`hi2c`: I2C 핸들러 (I2C_HandleTypeDef 구조체)입니다. I2C 통신을 관리하는 핸들러를 전달합니다. 이 핸들러는 통신에 필요한 설정 정보를 담고 있습니다.      <br>
`DevAddress`: I2C 슬레이브 장치의 주소입니다. 예를 들어, 0x68(MPU9250)와 같이 7비트 주소를 사용합니다.                                          <br>
`MemAddress`: 장치의 메모리 주소입니다. 데이터를 쓸 위치를 지정하는 주소입니다. 예를 들어, 0x6B는 MPU9250의 전원 관리 레지스터(PWR_MGMT_1) 주소입니다.      <br>
`MemAddSize`: 메모리 주소의 크기를 지정하는 값입니다. 보통 1, 2 또는 4바이트로 설정됩니다. (예: 1이면 1바이트 메모리 주소를 사용)       <br>   
`pData`: 쓰기 데이터입니다. I2C 장치의 메모리에 쓸 데이터를 담고 있는 버퍼입니다.           <br>
`Size`: 쓰기 데이터의 크기입니다. 버퍼에 담겨 있는 데이터의 길이를 지정합니다.              <br>
`Timeout`: 타임아웃 시간입니다. I2C 통신이 완료될 때까지 기다릴 시간(밀리초)을 지정합니다.

#### **동작 방식**
`HAL_I2C_Mem_Write()`는 I2C 마스터가 지정된 슬레이브 장치의 메모리 주소에 데이터를 기록하는 함수입니다. 아래는 그 동작 과정입니다:

1. **슬레이브 주소 전송**: 먼저, 슬레이브 장치 주소와 메모리 주소를 전송합니다.
2. **데이터 전송**: 메모리 주소를 정한 뒤, 실제 데이터를 전송합니다.
3. **응답 대기**: 데이터를 전송하고 나면, I2C 마스터는 슬레이브의 응답을 기다립니다.

### `HAL_I2C_Mem_Write()`와 `HAL_I2C_Mem_Read()`의 차이점
- `HAL_I2C_Mem_Read()`: 장치의 메모리에서 데이터를 읽어오는 함수입니다.
- `HAL_I2C_Mem_Write()`: 장치의 메모리에 데이터를 쓰기 위한 함수입니다.

### **I2C 통신의 읽기와 쓰기**
- **읽기**: 마스터는 슬레이브 장치의 메모리에서 데이터를 요청하고, 슬레이브는 그 데이터를 반환합니다.
- **쓰기**: 마스터는 슬레이브 장치의 메모리에 데이터를 전달하고, 슬레이브는 그 값을 메모리에 기록합니다.